import { Children, Component, PureComponent, createElement } from 'react';
import { classNames, variationName } from '@shopify/react-utilities/styles';
import { __decorate, __rest } from 'tslib';
import { classNames as classNames$1, variationName as variationName$1 } from '@shopify/react-utilities';
import { elementChildren, isElementOfType, layeredComponent, wrapWithComponent } from '@shopify/react-utilities/components';
import { autobind, debounce } from '@shopify/javascript-utilities/decorators';
import { createUniqueIDFactory, noop } from '@shopify/javascript-utilities/other';
import { bool, object } from 'prop-types';
import { addEventListener, removeEventListener } from '@shopify/javascript-utilities/events';
import { read, write } from '@shopify/javascript-utilities/fastdom';
import { clamp } from '@shopify/javascript-utilities/math';
import { Months, Weekdays, abbreviationForWeekday, dateIsInRange, dateIsSelected, getNewRange, getNextDisplayMonth, getNextDisplayYear, getPreviousDisplayMonth, getPreviousDisplayYear, getWeeksForMonth, isDateAfter, isDateBefore, isSameDay } from '@shopify/javascript-utilities/dates';
import isEqual from 'lodash/isEqual';
import pick from 'lodash/pick';
import { findFirstFocusableNode, focusFirstFocusableNode } from '@shopify/javascript-utilities/focus';
import { closest, nodeContainsDescendant } from '@shopify/javascript-utilities/dom';
import { Transition } from 'react-transition-group';
import { Rect, getRectForNode } from '@shopify/javascript-utilities/geometry';
import { findDOMNode } from 'react-dom';

var Keys;
(function (Keys) {
    Keys[Keys["BACKSPACE"] = 8] = "BACKSPACE";
    Keys[Keys["TAB"] = 9] = "TAB";
    Keys[Keys["ENTER"] = 13] = "ENTER";
    Keys[Keys["SHIFT"] = 16] = "SHIFT";
    Keys[Keys["CTRL"] = 17] = "CTRL";
    Keys[Keys["ALT"] = 18] = "ALT";
    Keys[Keys["PAUSE"] = 19] = "PAUSE";
    Keys[Keys["CAPS_LOCK"] = 20] = "CAPS_LOCK";
    Keys[Keys["ESCAPE"] = 27] = "ESCAPE";
    Keys[Keys["SPACE"] = 32] = "SPACE";
    Keys[Keys["PAGE_UP"] = 33] = "PAGE_UP";
    Keys[Keys["PAGE_DOWN"] = 34] = "PAGE_DOWN";
    Keys[Keys["END"] = 35] = "END";
    Keys[Keys["HOME"] = 36] = "HOME";
    Keys[Keys["LEFT_ARROW"] = 37] = "LEFT_ARROW";
    Keys[Keys["UP_ARROW"] = 38] = "UP_ARROW";
    Keys[Keys["RIGHT_ARROW"] = 39] = "RIGHT_ARROW";
    Keys[Keys["DOWN_ARROW"] = 40] = "DOWN_ARROW";
    Keys[Keys["INSERT"] = 45] = "INSERT";
    Keys[Keys["DELETE"] = 46] = "DELETE";
    Keys[Keys["KEY_0"] = 48] = "KEY_0";
    Keys[Keys["KEY_1"] = 49] = "KEY_1";
    Keys[Keys["KEY_2"] = 50] = "KEY_2";
    Keys[Keys["KEY_3"] = 51] = "KEY_3";
    Keys[Keys["KEY_4"] = 52] = "KEY_4";
    Keys[Keys["KEY_5"] = 53] = "KEY_5";
    Keys[Keys["KEY_6"] = 54] = "KEY_6";
    Keys[Keys["KEY_7"] = 55] = "KEY_7";
    Keys[Keys["KEY_8"] = 56] = "KEY_8";
    Keys[Keys["KEY_9"] = 57] = "KEY_9";
    Keys[Keys["KEY_A"] = 65] = "KEY_A";
    Keys[Keys["KEY_B"] = 66] = "KEY_B";
    Keys[Keys["KEY_C"] = 67] = "KEY_C";
    Keys[Keys["KEY_D"] = 68] = "KEY_D";
    Keys[Keys["KEY_E"] = 69] = "KEY_E";
    Keys[Keys["KEY_F"] = 70] = "KEY_F";
    Keys[Keys["KEY_G"] = 71] = "KEY_G";
    Keys[Keys["KEY_H"] = 72] = "KEY_H";
    Keys[Keys["KEY_I"] = 73] = "KEY_I";
    Keys[Keys["KEY_J"] = 74] = "KEY_J";
    Keys[Keys["KEY_K"] = 75] = "KEY_K";
    Keys[Keys["KEY_L"] = 76] = "KEY_L";
    Keys[Keys["KEY_M"] = 77] = "KEY_M";
    Keys[Keys["KEY_N"] = 78] = "KEY_N";
    Keys[Keys["KEY_O"] = 79] = "KEY_O";
    Keys[Keys["KEY_P"] = 80] = "KEY_P";
    Keys[Keys["KEY_Q"] = 81] = "KEY_Q";
    Keys[Keys["KEY_R"] = 82] = "KEY_R";
    Keys[Keys["KEY_S"] = 83] = "KEY_S";
    Keys[Keys["KEY_T"] = 84] = "KEY_T";
    Keys[Keys["KEY_U"] = 85] = "KEY_U";
    Keys[Keys["KEY_V"] = 86] = "KEY_V";
    Keys[Keys["KEY_W"] = 87] = "KEY_W";
    Keys[Keys["KEY_X"] = 88] = "KEY_X";
    Keys[Keys["KEY_Y"] = 89] = "KEY_Y";
    Keys[Keys["KEY_Z"] = 90] = "KEY_Z";
    Keys[Keys["LEFT_META"] = 91] = "LEFT_META";
    Keys[Keys["RIGHT_META"] = 92] = "RIGHT_META";
    Keys[Keys["SELECT"] = 93] = "SELECT";
    Keys[Keys["NUMPAD_0"] = 96] = "NUMPAD_0";
    Keys[Keys["NUMPAD_1"] = 97] = "NUMPAD_1";
    Keys[Keys["NUMPAD_2"] = 98] = "NUMPAD_2";
    Keys[Keys["NUMPAD_3"] = 99] = "NUMPAD_3";
    Keys[Keys["NUMPAD_4"] = 100] = "NUMPAD_4";
    Keys[Keys["NUMPAD_5"] = 101] = "NUMPAD_5";
    Keys[Keys["NUMPAD_6"] = 102] = "NUMPAD_6";
    Keys[Keys["NUMPAD_7"] = 103] = "NUMPAD_7";
    Keys[Keys["NUMPAD_8"] = 104] = "NUMPAD_8";
    Keys[Keys["NUMPAD_9"] = 105] = "NUMPAD_9";
    Keys[Keys["MULTIPLY"] = 106] = "MULTIPLY";
    Keys[Keys["ADD"] = 107] = "ADD";
    Keys[Keys["SUBTRACT"] = 109] = "SUBTRACT";
    Keys[Keys["DECIMAL"] = 110] = "DECIMAL";
    Keys[Keys["DIVIDE"] = 111] = "DIVIDE";
    Keys[Keys["F1"] = 112] = "F1";
    Keys[Keys["F2"] = 113] = "F2";
    Keys[Keys["F3"] = 114] = "F3";
    Keys[Keys["F4"] = 115] = "F4";
    Keys[Keys["F5"] = 116] = "F5";
    Keys[Keys["F6"] = 117] = "F6";
    Keys[Keys["F7"] = 118] = "F7";
    Keys[Keys["F8"] = 119] = "F8";
    Keys[Keys["F9"] = 120] = "F9";
    Keys[Keys["F10"] = 121] = "F10";
    Keys[Keys["F11"] = 122] = "F11";
    Keys[Keys["F12"] = 123] = "F12";
    Keys[Keys["NUM_LOCK"] = 144] = "NUM_LOCK";
    Keys[Keys["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
    Keys[Keys["SEMICOLON"] = 186] = "SEMICOLON";
    Keys[Keys["EQUALS"] = 187] = "EQUALS";
    Keys[Keys["COMMA"] = 188] = "COMMA";
    Keys[Keys["DASH"] = 189] = "DASH";
    Keys[Keys["PERIOD"] = 190] = "PERIOD";
    Keys[Keys["FORWARD_SLASH"] = 191] = "FORWARD_SLASH";
    Keys[Keys["GRAVE_ACCENT"] = 192] = "GRAVE_ACCENT";
    Keys[Keys["OPEN_BRACKET"] = 219] = "OPEN_BRACKET";
    Keys[Keys["BACK_SLASH"] = 220] = "BACK_SLASH";
    Keys[Keys["CLOSE_BRACKET"] = 221] = "CLOSE_BRACKET";
    Keys[Keys["SINGLE_QUOTE"] = 222] = "SINGLE_QUOTE";
})(Keys || (Keys = {}));

function Image$1(_a) {
    var { sourceSet, source } = _a,
        rest = __rest(_a, ["sourceSet", "source"]);
    const finalSourceSet = sourceSet ? sourceSet.map(({ source: subSource, descriptor }) => `${subSource} ${descriptor}`).join(',') : null;
    return finalSourceSet ?
    // eslint-disable-next-line jsx-a11y/alt-text
    createElement("img", Object.assign({ src: source, srcSet: finalSourceSet }, rest)) :
    // eslint-disable-next-line jsx-a11y/alt-text
    createElement("img", Object.assign({ src: source }, rest));
}

var styles$1 = {
  "Avatar": "p_vw",
  "sizeSmall": "p_bj",
  "sizeMedium": "p_hf",
  "sizeLarge": "p_t5",
  "styleOne": "p_a6",
  "styleTwo": "p_uk",
  "styleThree": "p_pf",
  "styleFour": "p_ve",
  "styleFive": "p_j8",
  "styleSix": "p_of",
  "hasImage": "p_hl",
  "Image": "p_sq",
  "Initials": "p_ie",
  "Svg": "p_y1",
  "skeletonShimmerAnimation": "p_eq",
};

var avatar1 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzI0NWI0OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiNmZmZ9LmNscy00e2ZpbGw6IzhkYzk1OH0uY2xzLTV7ZmlsbDojZWJlZGYxO29wYWNpdHk6LjJ9PC9zdHlsZT48L2RlZnM+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMCAwaDEwMHYxMDBIMHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02OSAwdjY1LjY1bC0yLS4wMXYxOS44NWwyIC4wMlYxMDBIMFYwaDY5eiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY3IDY1LjY0djE5Ljg1bC0yNS41Ny0uMTlDMzIgODUuMjIgMjUuNiA4MS40NiAyNS42OCA3Mi4wNnMuMjUtNi43NC4yNS02Ljc0eiIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTg2Ljk5IDU4SDY5VjBoMTAuOTNsNy4wNiA1OHoiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik0yNC41MyA0MC4yOWExMi4yMyAxMi4yMyAwIDAgMSAyNC40NiAwIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNTkuNjIgNThBMTAuNjkgMTAuNjkgMCAwIDEgODEgNTh6Ii8+PC9zdmc+';

var avatar2 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzFlMjY1Y30uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtMywuY2xzLTV7ZmlsbDojZmZmfS5jbHMtNHtmaWxsOiNmZmMwNGR9LmNscy01e3N0cm9rZTojZmZmO3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTS0uMDEgMGgxMDB2MTAwaC0xMDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNLS4wMSAwaDY5LjAydjEwMEgtLjAxeiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY4LjkzIDY1Ljg4bC0yNC40NC0uMTktLjA1IDYuMDljMCA1LjIyIDMuNDggOS40NyA4LjY5IDkuNTJsMTUuOC4xMnoiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik02OC45MSAxMS4zbDE5LjE3IDQ2LjI5LTE5LjE3LS4xNlYxMS4zeiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTIzLjI1IDM2LjQzYTMuMjIgMy4yMiAwIDEgMCAwIDYuNDRtMjEuMDEtNi40NGEzLjIyIDMuMjIgMCAwIDAgMCA2LjQ0bS0xMy41NSAzLjc0YTMuMjIgMy4yMiAwIDEgMCAwIDYuNDRtMy4yMi0yNS41MWEzLjIyIDMuMjIgMCAwIDAgMCA2LjQ0Ii8+PC9zdmc+';

var avatar3 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzVkNmNjMX0uY2xzLTJ7ZmlsbDojNmRjYWNlfS5jbHMtM3tmaWxsOm5vbmU7c3Ryb2tlOiNmZmY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLXdpZHRoOjVweH0uY2xzLTR7ZmlsbDojZWJlZGYxO29wYWNpdHk6LjJ9LmNscy01e2ZpbGw6I2ZmZn08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0tLjAyIDBoMTAwdjEwMGgtMTAweiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTS4zOSAwaDY5LjAydjEwMEguMzl6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNMjQuMTggMzEuMjF2My40N0ExMC40MyAxMC40MyAwIDAgMCAzNC40IDQ1LjIxYTEwLjQzIDEwLjQzIDAgMCAwIDEwLjIyLTEwLjUzdi0zLjQ3Ii8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNMjAuMTEgNDkuMDdhMTYuMjIgMTYuMjIgMCAxIDEgMCAzMi40NCIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTY5LjQ0IDE4LjgzTDkwIDcxSDY5LjQ0VjE4LjgzeiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTU3LjU5IDcxYTYgNiAwIDAgMSAxMiAweiIvPjwvc3ZnPg==';

var avatar4 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZTBjM30uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtM3tmaWxsOiNmZjk2N2R9LmNscy00e2ZpbGw6bm9uZTtzdHJva2U6I2ZmZjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2Utd2lkdGg6NXB4fS5jbHMtNXtmaWxsOiNlYmVkZjE7b3BhY2l0eTouMn08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0wLS4wMWgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjAydjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTY5LjAyIDBsMjQuMDMgNjEuNjlINjkuMDJWMHoiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik0zMC42OSAzMS45MXYtM2MwLTQuNzggMy40Ni04LjY1IDgtOC42NXM4IDMuODcgOCA4LjY1djMiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik0xMi43NiA1Ni4wNmExMy4zNiAxMy4zNiAwIDEgMSAyNi43MiAwIi8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNODAgNjEuNDZsLTI5LjM0LjIzdi03LjMzYzAtNi4yOCA0LjA3LTExLjM2IDEwLjM0LTExLjQ0bDE5LS4xNHoiLz48L3N2Zz4=';

var avatar5 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzhkYzk1OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiMyNDViNDh9LmNscy00e2ZpbGw6I2ViZWRmMTtvcGFjaXR5Oi4yfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGg3MC4wMnYxMDBIMHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02OS45MiAwdjU2LjMyTDQ5IDY3bC0uMyAyNS4wN1YxMDBIMTAwVjB6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNNTkuMjcgNTguMjlhNS4yMiA1LjIyIDAgMCAwLTkuNDMgNC40OCIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTI3LjEyIDkuMzNoNDQuNTN2Mi4xOUgyNy4xMnptLTEyLjQxIDkuNDloNTYuOTR2Mi4xOUgxNC43MXoiLz48Y2lyY2xlIGNsYXNzPSJjbHMtNCIgY3g9IjE5LjY2IiBjeT0iNDQuOCIgcj0iMTEuMjIiLz48L3N2Zz4=';

var avatar6 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZTBjM30uY2xzLTJ7ZmlsbDojZmY5NjdkfS5jbHMtM3tmaWxsOiMzMmNhYzZ9LmNscy00e2ZpbGw6IzAwOTc5Nn0uY2xzLTUsLmNscy02e2ZpbGw6bm9uZTtzdHJva2U6I2ZmZjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMH0uY2xzLTV7c3Ryb2tlLXdpZHRoOjVweH0uY2xzLTZ7c3Ryb2tlLXdpZHRoOjRweH08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0tLjAyLS4wMWgxMDB2MTAwaC0xMDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjQxdjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTY5LjkyIDB2NDQuMzJMNTEuMzQgNTV2NDVIMTAwVjB6Ii8+PHBhdGggY2xhc3M9ImNscy0zIiBkPSJNMzkuMzIgNzZhMTEuODUgMTEuODUgMCAwIDAgMTIgMTEuNjJWNzYiLz48cGF0aCBjbGFzcz0iY2xzLTQiIGQ9Ik0zOS4zMiA3NmExMiAxMiAwIDAgMSAxMi0xMS44MlY3NiIvPjxwYXRoIGNsYXNzPSJjbHMtNSIgZD0iTTQzLjc0IDE5LjgzYTEyLjgyIDEyLjgyIDAgMSAxLTI1LjY0IDAiLz48cGF0aCBjbGFzcz0iY2xzLTYiIGQ9Ik0yNy4zOSAzMS42bC0xLjU4IDUuOTZtOS4zNy01LjcybDIuNTUgNS40N200LjI2LTkuODVsMy41MyA0LjVtLTI1LjQzLTQuNWwtMy41MyA0LjUiLz48L3N2Zz4=';

var avatar7 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzhkYzk1OH0uY2xzLTJ7ZmlsbDojMmRiMTY3fS5jbHMtM3tmaWxsOiNmZmZ9LmNscy00e2ZpbGw6IzI0NWI0OH08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik0wIDBoMTAwdjEwMC40OEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTgzIDY4djMybC0xNC0uMTZ2LjE2SDBWMGg2OXY2OGgxNHoiLz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik02OS4yOSA0MS42OUgyMC42NnMtLjA5LTMtLjE3IDcuMTUgNyAxOC41MSAxNy4zNSAxOC41OWwzMS40NS41N3oiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik02OC43IDEyLjRsMTEuNTQgMjkuMjlINjguN1YxMi40eiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTYyLjIyIDQxLjY5YTMuMzQgMy4zNCAwIDEgMSA2LjY5IDB6Ii8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNDEuNDUgMTguMDZhMi41NyAyLjU3IDAgMCAwLTUuMTQgME0zMy4zMyAyNGEyLjU3IDIuNTcgMCAxIDAtNS4xNCAwbTIwLjM2IDIuNThhMi41NyAyLjU3IDAgMSAwLTUuMTQgMCIvPjwvc3ZnPg==';

var avatar8 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZWRiOX0uY2xzLTJ7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS13aWR0aDo1cHh9LmNscy0ze2ZpbGw6I2ZmYzA0ZH0uY2xzLTR7ZmlsbDojNWQ2Y2MxfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNNjQuNjMgMTcuMzNhMTcgMTcgMCAwIDEgNSAyOS43MiAxNi43NSAxNi43NSAwIDAgMS01IDIuNjIiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik0wIDBoNjkuMDJ2MTAwSDB6Ii8+PGNpcmNsZSBjbGFzcz0iY2xzLTIiIGN4PSI0NS4xMSIgY3k9IjMzLjQ5IiByPSIxNi45OCIgdHJhbnNmb3JtPSJyb3RhdGUoLTM3LjAyIDQ1LjEyNCAzMy40OTMpIi8+PHBhdGggY2xhc3M9ImNscy00IiBkPSJNNjkuMDIgMzQuNDhsMTkuNDcgMzguNzQtMTkuNDcgMS41M1YzNC40OHoiLz48cGF0aCBjbGFzcz0iY2xzLTIiIGQ9Ik02MS42IDMzLjY3YTEwLjE3IDEwLjE3IDAgMCAxIDE1LjQuMDgiLz48L3N2Zz4=';

var avatar9 = 'data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmYzA0ZH0uY2xzLTJ7ZmlsbDojNWQ2Y2MxfS5jbHMtM3tmaWxsOiM0MTIzNmV9LmNscy00e2ZpbGw6I2ViZWRmMTtvcGFjaXR5Oi4yfTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHBhdGggY2xhc3M9ImNscy0yIiBkPSJNMCAwaDY5LjQxdjEwMEgweiIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTcwLjIxIDgwLjg4aC0xNS4xYy00LjgxIDAtNS42OC01Ljg0LTUuNjgtNS44NGgyMC43OCIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTgyIDYwLjQ4bC0xNCAuMjVWMGgxMC4xN0M4MC41OSAyMC4xNCA4MiA2MC40OCA4MiA2MC40OHoiLz48cGF0aCBjbGFzcz0iY2xzLTMiIGQ9Ik01Ny43MSA2MC40OGE1LjQ0IDUuNDQgMCAxIDEgMTAuODcgMCIvPjxjaXJjbGUgY2xhc3M9ImNscy00IiBjeD0iMjQuNzciIGN5PSI0MC4xOSIgcj0iMTEuMjIiLz48L3N2Zz4=';



var avatars = Object.freeze({
	avatarOne: avatar1,
	avatarTwo: avatar2,
	avatarThree: avatar3,
	avatarFour: avatar4,
	avatarFive: avatar5,
	avatarSix: avatar6,
	avatarSeven: avatar7,
	avatarEight: avatar8,
	avatarNine: avatar9
});

const STYLE_CLASSES = ['one', 'two', 'three', 'four', 'five', 'six'];
const AVATAR_IMAGES = Object.keys(avatars).map(key => avatars[key]);
function Avatar$1({ name, source, initials, customer, size = 'medium', accessibilityLabel }) {
    const nameString = name || initials;
    let finalSource;
    let label;
    if (accessibilityLabel) {
        label = accessibilityLabel;
    } else if (name) {
        label = name;
    } else if (initials) {
        label = `Avatar with initials ${initials.split('').join(' ')}`;
    } else {
        label = 'Avatar';
    }
    if (source) {
        finalSource = source;
    } else if (customer) {
        finalSource = customerPlaceholder(nameString);
    }
    const className = classNames(styles$1.Avatar, styles$1[variationName('style', styleClass(nameString))], size && styles$1[variationName('size', size)], finalSource && styles$1.hasImage);
    const imageMarkUp = finalSource ? createElement(Image$1, { className: styles$1.Image, source: finalSource, alt: '', role: 'presentation' }) : null;
    // Use `dominant-baseline: central` instead of `dy` when Edge supports it.
    const verticalOffset = '0.35em';
    const initialsMarkup = initials ? createElement(
        'span',
        { className: styles$1.Initials },
        createElement(
            'svg',
            { className: styles$1.Svg, viewBox: '0 0 48 48' },
            createElement(
                'text',
                { x: '50%', y: '50%', dy: verticalOffset, fill: 'currentColor', fontSize: '26', textAnchor: 'middle' },
                initials
            )
        )
    ) : null;
    return createElement(
        'span',
        { 'aria-label': label, role: 'img', className: className },
        initialsMarkup,
        imageMarkUp
    );
}
function styleClass(name) {
    return name ? STYLE_CLASSES[name.charCodeAt(0) % STYLE_CLASSES.length] : STYLE_CLASSES[0];
}
function customerPlaceholder(name) {
    return name ? AVATAR_IMAGES[name.charCodeAt(0) % AVATAR_IMAGES.length] : AVATAR_IMAGES[0];
}

function handleMouseUpByBlurring({ currentTarget }) {
    currentTarget.blur();
}

const scrollable = {
    props: { 'data-polaris-scrollable': true },
    selector: '[data-polaris-scrollable]'
};
const overlay = {
    props: { 'data-polaris-overlay': true },
    selector: '[data-polaris-overlay]'
};
const layer = {
    props: { 'data-polaris-layer': true },
    selector: '[data-polaris-layer]'
};
const unstyled = {
    props: { 'data-polaris-unstyled': true },
    selector: '[data-polaris-unstyled]'
};

let LinkComponent;
class UnstyledLink$1 extends PureComponent {
    static use(NewLinkComponent) {
        LinkComponent = NewLinkComponent;
    }
    render() {
        if (LinkComponent) {
            return createElement(LinkComponent, Object.assign({}, unstyled.props, this.props));
        }
        const _a = this.props,
              { external, url } = _a,
              rest = __rest(_a, ["external", "url"]);
        const target = external ? '_blank' : undefined;
        const rel = external ? 'noopener noreferrer' : undefined;
        return createElement('a', Object.assign({ target: target }, rest, { href: url, rel: rel }, unstyled.props));
    }
}

var add = {"viewBox":"0 0 20 20","body":"<path d=\"M17 9h-6V3a1 1 0 1 0-2 0v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2\"  fill-rule=\"evenodd\"/>"};

var alert = {"viewBox":"0 0 20 20","body":"<path d=\"M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm-1-8h2V6H9v4zm0 4h2v-2H9v2z\"  fill-rule=\"evenodd\"/>"};

var arrowDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10.707 17.707l5-5a.999.999 0 1 0-1.414-1.414L11 14.586V3a1 1 0 1 0-2 0v11.586l-3.293-3.293a.999.999 0 1 0-1.414 1.414l5 5a.999.999 0 0 0 1.414 0\"  fill-rule=\"evenodd\"/>"};

var arrowLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M17 9H5.414l3.293-3.293a.999.999 0 1 0-1.414-1.414l-5 5a.999.999 0 0 0 0 1.414l5 5a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L5.414 11H17a1 1 0 1 0 0-2\"  fill-rule=\"evenodd\"/>"};

var arrowRight = {"viewBox":"0 0 20 20","body":"<path d=\"M17.707 9.293l-5-5a.999.999 0 1 0-1.414 1.414L14.586 9H3a1 1 0 1 0 0 2h11.586l-3.293 3.293a.999.999 0 1 0 1.414 1.414l5-5a.999.999 0 0 0 0-1.414\"  fill-rule=\"evenodd\"/>"};

var arrowUp = {"viewBox":"0 0 20 20","body":"<path d=\"M11 17V5.414l3.293 3.293a.999.999 0 1 0 1.414-1.414l-5-5a.999.999 0 0 0-1.414 0l-5 5a.997.997 0 0 0 0 1.414.999.999 0 0 0 1.414 0L9 5.414V17a1 1 0 1 0 2 0\"  fill-rule=\"evenodd\"/>"};

var arrowUpDown = {"viewBox":"0 0 20 20","body":"<path d=\"M13 8l-3-3-3 3h6zm-.1 4L10 14.9 7.1 12h5.8z\"  fill-rule=\"evenodd\"/>"};

var calendar = {"viewBox":"0 0 20 20","body":"<path d=\"M4 8h12V6H4v2zm9 4h2v-2h-2v2zm-4 0h2v-2H9v2zm0 4h2v-2H9v2zm-4-4h2v-2H5v2zm0 4h2v-2H5v2zM17 4h-2V3a1 1 0 1 0-2 0v1H7V3a1 1 0 1 0-2 0v1H3a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var cancel = {"viewBox":"0 0 20 20","body":"<path d=\"M11.414 10l6.293-6.293a.999.999 0 1 0-1.414-1.414L10 8.586 3.707 2.293a.999.999 0 1 0-1.414 1.414L8.586 10l-6.293 6.293a.999.999 0 1 0 1.414 1.414L10 11.414l6.293 6.293a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L11.414 10z\"  fill-rule=\"evenodd\"/>"};

var cancelSmall = {"viewBox":"0 0 20 20","body":"<path d=\"M11.414 10l4.293-4.293a.999.999 0 1 0-1.414-1.414L10 8.586 5.707 4.293a.999.999 0 1 0-1.414 1.414L8.586 10l-4.293 4.293a.999.999 0 1 0 1.414 1.414L10 11.414l4.293 4.293a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414L11.414 10z\"  fill-rule=\"evenodd\"/>"};

var caretDown = {"viewBox":"0 0 20 20","body":"<path d=\"M5 8l5 5 5-5z\"  fill-rule=\"evenodd\"/>"};

var caretUp = {"viewBox":"0 0 20 20","body":"<path d=\"M15 12l-5-5-5 5z\" />"};

var checkmark = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><path d=\"M8.315 13.859l-3.182-3.417a.506.506 0 0 1 0-.684l.643-.683a.437.437 0 0 1 .642 0l2.22 2.393 4.942-5.327a.437.437 0 0 1 .643 0l.643.684a.504.504 0 0 1 0 .683l-5.91 6.35a.437.437 0 0 1-.642 0\"/><path d=\"M8.315 13.859l-3.182-3.417a.506.506 0 0 1 0-.684l.643-.683a.437.437 0 0 1 .642 0l2.22 2.393 4.942-5.327a.437.437 0 0 1 .643 0l.643.684a.504.504 0 0 1 0 .683l-5.91 6.35a.437.437 0 0 1-.642 0\"/></g>"};

var chevronDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10 14a.997.997 0 0 1-.707-.293l-5-5a.999.999 0 1 1 1.414-1.414L10 11.586l4.293-4.293a.999.999 0 1 1 1.414 1.414l-5 5A.997.997 0 0 1 10 14\"  fill-rule=\"evenodd\"/>"};

var chevronLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M12 16a.997.997 0 0 1-.707-.293l-5-5a.999.999 0 0 1 0-1.414l5-5a.999.999 0 1 1 1.414 1.414L8.414 10l4.293 4.293A.999.999 0 0 1 12 16\"  fill-rule=\"evenodd\"/>"};

var chevronRight = {"viewBox":"0 0 20 20","body":"<path d=\"M8 16a.999.999 0 0 1-.707-1.707L11.586 10 7.293 5.707a.999.999 0 1 1 1.414-1.414l5 5a.999.999 0 0 1 0 1.414l-5 5A.997.997 0 0 1 8 16\"  fill-rule=\"evenodd\"/>"};

var chevronUp = {"viewBox":"0 0 20 20","body":"<path d=\"M15 13a.997.997 0 0 1-.707-.293L10 8.414l-4.293 4.293a.999.999 0 1 1-1.414-1.414l5-5a.999.999 0 0 1 1.414 0l5 5A.999.999 0 0 1 15 13\"  fill-rule=\"evenodd\"/>"};

var circleCancel = {"viewBox":"0 0 20 20","body":"<path d=\"M14.242 12.829l-1.414 1.414L10 11.413l-2.828 2.83-1.414-1.414 2.828-2.83-2.828-2.827 1.414-1.414L10 8.586l2.828-2.828 1.414 1.414L11.414 10l2.828 2.829zM10 1.999A8 8 0 1 0 10 18a8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronDown = {"viewBox":"0 0 20 20","body":"<path d=\"M10 13.414L5.293 8.707l1.414-1.414L10 10.586l3.293-3.293 1.414 1.414L10 13.414zM10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronLeft = {"viewBox":"0 0 20 20","body":"<path d=\"M11.293 5.293l1.414 1.414L9.414 10l3.293 3.293-1.414 1.414L6.586 10l4.707-4.707zM10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronRight = {"viewBox":"0 0 20 20","body":"<path d=\"M8.707 14.707l-1.414-1.414L10.586 10 7.293 6.707l1.414-1.414L13.414 10l-4.707 4.707zM10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16z\"  fill-rule=\"evenodd\"/>"};

var circleChevronUp = {"viewBox":"0 0 20 20","body":"<path d=\"M14.707 11.293l-1.414 1.414L10 9.414l-3.293 3.293-1.414-1.414L10 6.586l4.707 4.707zM18 10a8 8 0 1 0-16 0 8 8 0 0 0 16 0z\"  fill-rule=\"evenodd\"/>"};

var circlePlus = {"viewBox":"0 0 20 20","body":"<path d=\"M15 11h-4v4H9v-4H5V9h4V5h2v4h4v2zm-5-9a8 8 0 1 0 0 16 8 8 0 0 0 0-16z\"  fill-rule=\"evenodd\"/>"};

var conversation = {"viewBox":"0 0 20 20","body":"<path d=\"M13 11h2V9h-2v2zm-4 0h2V9H9v2zm-4 0h2V9H5v2zm5-9c-4.411 0-8 3.589-8 8 0 1.504.425 2.908 1.15 4.111l-1.069 2.495a1 1 0 0 0 1.314 1.313l2.494-1.069A7.939 7.939 0 0 0 10 18c4.411 0 8-3.589 8-8s-3.589-8-8-8z\"  fill-rule=\"evenodd\"/>"};

var deleteIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M16 6H4a1 1 0 1 0 0 2h1v9a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V8h1a1 1 0 1 0 0-2zM9 4a1 1 0 1 1 0-2h2a1 1 0 1 1 0 2H9zm2 12h2V8h-2v8zm-4 0h2V8H7v8z\"  fill-rule=\"evenodd\"/>"};

var disable = {"viewBox":"0 0 20 20","body":"<path d=\"M10 16a5.961 5.961 0 0 1-3.471-1.115l8.356-8.356A5.961 5.961 0 0 1 16 10c0 3.309-2.691 6-6 6m0-12c1.294 0 2.49.416 3.471 1.115l-8.356 8.356A5.961 5.961 0 0 1 4 10c0-3.309 2.691-6 6-6m0-2c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8\"  fill-rule=\"evenodd\"/>"};

var dispute = {"viewBox":"0 0 20 20","body":"<path d=\"M9 10h2V6H9v4zm0 4h2v-2H9v2zm-7-4c0 4.411 3.589 8 8 8a7.939 7.939 0 0 0 4.111-1.15l2.494 1.069a1 1 0 0 0 1.314-1.313l-1.069-2.495A7.939 7.939 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8z\"  fill-rule=\"evenodd\"/>"};

var duplicate = {"viewBox":"0 0 20 20","body":"<path d=\"M8 12h8V4H8v8zm4 4H4V8h2v5a1 1 0 0 0 1 1h5v2zm5-14H7a1 1 0 0 0-1 1v3H3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-3h3a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var embed = {"viewBox":"0 0 20 20","body":"<path d=\"M17 13a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-3a1 1 0 1 1 2 0v2h12v-2a1 1 0 0 1 1-1zm0-11a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0V4H4v2a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1h14zm.555 7.168a1.001 1.001 0 0 1 0 1.664l-3 2a1 1 0 0 1-1.109-1.664L15.198 10l-1.752-1.168a1 1 0 1 1 1.109-1.664l3 2zM6.832 7.445a1 1 0 0 1-.277 1.387L4.803 10l1.752 1.168a1 1 0 1 1-1.11 1.664l-3-2a1.001 1.001 0 0 1 0-1.664l3-2a1 1 0 0 1 1.387.277zM9 14.001a1 1 0 0 1-.948-1.317l2-6a1 1 0 0 1 1.896.633l-2 6A.999.999 0 0 1 9 14z\"  fill-rule=\"evenodd\"/>"};

var exportIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M9.293 13.707l-3-3a.999.999 0 1 1 1.414-1.414L9 10.586V3a1 1 0 1 1 2 0v7.586l1.293-1.293a.999.999 0 1 1 1.414 1.414l-3 3a.999.999 0 0 1-1.414 0zM17 16a1 1 0 1 1 0 2H3a1 1 0 1 1 0-2h14z\"/>"};

var external = {"viewBox":"0 0 20 20","body":"<path d=\"M17 2a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0V5.414l-7.293 7.293a.997.997 0 0 1-1.414 0 .999.999 0 0 1 0-1.414L14.586 4H13a1 1 0 1 1 0-2h4zm-4 9a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2H4v8h8v-4a1 1 0 0 1 1-1z\"  fill-rule=\"evenodd\"/>"};

var help = {"viewBox":"0 0 20 20","body":"<circle cx=\"10\" cy=\"10\" r=\"9\" fill=\"currentColor\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8m0-4a1 1 0 1 0 0 2 1 1 0 1 0 0-2m0-10C8.346 4 7 5.346 7 7a1 1 0 1 0 2 0 1.001 1.001 0 1 1 1.591.808C9.58 8.548 9 9.616 9 10.737V11a1 1 0 1 0 2 0v-.263c0-.653.484-1.105.773-1.317A3.013 3.013 0 0 0 13 7c0-1.654-1.346-3-3-3\" />"};

var horizontalDots = {"viewBox":"0 0 20 20","body":"<path d=\"M6 10a2 2 0 1 1-4.001-.001A2 2 0 0 1 6 10zm6 0a2 2 0 1 1-4.001-.001A2 2 0 0 1 12 10zm6 0a2 2 0 1 1-4.001-.001A2 2 0 0 1 18 10z\"  fill-rule=\"evenodd\"/>"};

var importIcon = {"viewBox":"0 0 20 20","body":"<path d=\"M13.707 6.707a.997.997 0 0 1-1.414 0L11 5.414V13a1 1 0 1 1-2 0V5.414L7.707 6.707a.999.999 0 1 1-1.414-1.414l3-3a.999.999 0 0 1 1.414 0l3 3a.999.999 0 0 1 0 1.414zM17 18H3a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2z\"/>"};

var notes = {"viewBox":"0 0 20 20","body":"<path d=\"M6 11h8V9H6v2zm0 4h8v-2H6v2zm0-8h4V5H6v2zm9.707-1.707l-3-3A.996.996 0 0 0 12 2H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V6a.997.997 0 0 0-.293-.707z\"  fill-rule=\"evenodd\"/>"};

var notification = {"viewBox":"0 0 20 20","body":"<path d=\"M16 8c0-2.967-2.167-5.432-5-5.91V1a1 1 0 1 0-2 0v1.09C6.167 2.568 4 5.033 4 8c0 2.957 0 4.586-1.707 6.293A1 1 0 0 0 3 16h4.183A2.909 2.909 0 0 0 7 17c0 1.654 1.345 3 3 3s3-1.346 3-3c0-.353-.07-.687-.184-1H17a1 1 0 0 0 .707-1.707C16 12.586 16 10.957 16 8zM5.011 14C6 12.208 6 10.285 6 8c0-2.206 1.794-4 4-4s4 1.794 4 4c0 2.285 0 4.208.989 6H5.011zM11 17a1.001 1.001 0 0 1-2 0 1 1 0 0 1 2 0z\"/>"};

var print = {"viewBox":"0 0 20 20","body":"<path d=\"M14 11h2V9h-2v2zM7 7h6V4H7v3zm0 9h6v-2H7v2zm10-9h-2V3a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v4H3a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h2v1a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h2a1 1 0 0 0 1-1V8a1 1 0 0 0-1-1z\"  fill-rule=\"evenodd\"/>"};

var subtract = {"viewBox":"0 0 20 20","body":"<path d=\"M15 9H5a1 1 0 1 0 0 2h10a1 1 0 1 0 0-2\"  fill-rule=\"evenodd\"/>"};

var refresh = {"viewBox":"0 0 20 20","body":"<path d=\"M17 11a1 1 0 0 1 1 1c0 1.654-1.346 3-3 3H5.414l1.293 1.293a.999.999 0 1 1-1.414 1.414l-3-3a.999.999 0 0 1 0-1.414l3-3a.999.999 0 1 1 1.414 1.414L5.414 13H15c.552 0 1-.449 1-1a1 1 0 0 1 1-1zM3 9a1 1 0 0 1-1-1c0-1.654 1.346-3 3-3h9.586l-1.293-1.293a.999.999 0 1 1 1.414-1.414l3 3a.999.999 0 0 1 0 1.414l-3 3a.997.997 0 0 1-1.414 0 .999.999 0 0 1 0-1.414L14.586 7H5c-.552 0-1 .449-1 1a1 1 0 0 1-1 1z\"  fill-rule=\"evenodd\"/>"};

var risk = {"viewBox":"0 0 20 20","body":"<path d=\"M9 12h2V8H9v4zm0 4h2v-2H9v2zm8.895.509l-7-14c-.339-.678-1.451-.678-1.79 0l-7 14A.999.999 0 0 0 3 17.956h14a1.001 1.001 0 0 0 .895-1.447z\"  fill-rule=\"evenodd\"/>"};

var save = {"viewBox":"0 0 20 20","body":"<path d=\"M17 4h-3a1 1 0 1 0 0 2h2v10H4V4h3.586L9 5.414v5.172L7.707 9.293a1 1 0 0 0-1.414 1.414l3 3a.996.996 0 0 0 1.414 0l3-3a1 1 0 0 0-1.414-1.414L11 10.586V5a.997.997 0 0 0-.293-.707l-2-2A.994.994 0 0 0 8 2H3a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1z\"/>"};

var search = {"viewBox":"0 0 20 20","body":"<path d=\"M8 12a4 4 0 1 1 0-8 4 4 0 0 1 0 8m9.707 4.293l-4.82-4.82A5.968 5.968 0 0 0 14 8 6 6 0 0 0 2 8a6 6 0 0 0 6 6 5.968 5.968 0 0 0 3.473-1.113l4.82 4.82a.997.997 0 0 0 1.414 0 .999.999 0 0 0 0-1.414\"  fill-rule=\"evenodd\"/>"};

var view = {"viewBox":"0 0 20 20","body":"<path d=\"M17.928 9.628C17.836 9.399 15.611 4 9.999 4S2.162 9.399 2.07 9.628a1.017 1.017 0 0 0 0 .744C2.162 10.601 4.387 16 9.999 16s7.837-5.399 7.929-5.628a1.017 1.017 0 0 0 0-.744zM9.999 14a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm0-6A2 2 0 1 0 10 12.001 2 2 0 0 0 10 8z\"/>"};

var styles$2 = {
  "Icon": "p_sd",
  "hasBackdrop": "p_m6",
  "colorWhite": "p_wh",
  "colorBlack": "p_xv",
  "colorSkyLighter": "p_zk",
  "colorSkyLight": "p_vz",
  "colorSky": "p_ao",
  "colorSkyDark": "p_rg",
  "colorInkLightest": "p_uz",
  "colorInkLighter": "p_fm",
  "colorInkLight": "p_fv",
  "colorInk": "p_pj",
  "colorBlueLighter": "p_t0",
  "colorBlueLight": "p_mg",
  "colorBlue": "p_hj",
  "colorBlueDark": "p_i2",
  "colorBlueDarker": "p_fi",
  "colorIndigoLighter": "p_yb",
  "colorIndigoLight": "p_wn",
  "colorIndigo": "p_lh",
  "colorIndigoDark": "p_by",
  "colorIndigoDarker": "p_wq",
  "colorTealLighter": "p_lf",
  "colorTealLight": "p_zd",
  "colorTeal": "p_wt",
  "colorTealDark": "p_ai",
  "colorTealDarker": "p_z1",
  "colorGreenLighter": "p_ev",
  "colorGreen": "p_qs",
  "colorGreenDark": "p_rd",
  "colorYellowLighter": "p_x8",
  "colorYellow": "p_p1",
  "colorYellowDark": "p_cj",
  "colorOrange": "p_he",
  "colorOrangeDark": "p_zx",
  "colorRedLighter": "p_pl",
  "colorRed": "p_rc",
  "colorRedDark": "p_kn",
  "colorPurple": "p_ol",
  "Svg": "p_n8",
  "Placeholder": "p_uv",
  "skeletonShimmerAnimation": "p_aw",
};

const BUNDLED_ICONS = {
    add,
    alert,
    arrowDown,
    arrowLeft,
    arrowRight,
    arrowUp,
    arrowUpDown,
    calendar,
    cancel,
    cancelSmall,
    caretDown,
    caretUp,
    checkmark,
    chevronDown,
    chevronLeft,
    chevronRight,
    chevronUp,
    circleCancel,
    circleChevronDown,
    circleChevronLeft,
    circleChevronRight,
    circleChevronUp,
    circlePlus,
    conversation,
    delete: deleteIcon,
    disable,
    dispute,
    duplicate,
    embed,
    export: exportIcon,
    external,
    help,
    horizontalDots,
    import: importIcon,
    notes,
    notification,
    print,
    refresh,
    risk,
    save,
    search,
    subtract,
    view
};
const COLORS_WITH_BACKDROPS = ['teal', 'tealDark', 'greenDark', 'redDark', 'yellowDark', 'ink', 'inkLighter'];
function Icon$1({ source, color, backdrop, accessibilityLabel }) {
    if (color && backdrop && COLORS_WITH_BACKDROPS.indexOf(color) < 0) {
        // eslint-disable-next-line no-console
        console.warn(`The ${color} icon doesn’t accept backdrops. The icon colors that have backdrops are: ${COLORS_WITH_BACKDROPS.join(', ')}`);
    }
    const className = classNames(styles$2.Icon, color && styles$2[variationName('color', color)], backdrop && styles$2.hasBackdrop);
    let contentMarkup;
    if (source === 'placeholder') {
        contentMarkup = createElement('div', { className: styles$2.Placeholder });
    } else {
        const iconSource = typeof source === 'string' ? BUNDLED_ICONS[source] : source;
        contentMarkup = createElement('svg', { className: styles$2.Svg, viewBox: iconSource.viewBox, dangerouslySetInnerHTML: { __html: iconSource.body } });
    }
    return createElement(
        'span',
        { className: className, 'aria-label': accessibilityLabel },
        contentMarkup
    );
}

var styles$3 = {
  "Spinner": "p_f3",
  "loading": "p_yj",
  "sizeSmall": "p_d0",
  "sizeLarge": "p_x1",
  "colorWhite": "p_at",
  "colorTeal": "p_qq",
  "colorInkLightest": "p_lo",
  "skeletonShimmerAnimation": "p_xw",
};

var spinnerSVGLarge = {"viewBox":"0 0 44 44","body":"<path d=\"M15.542 1.487A21.507 21.507 0 0 0 .5 22c0 11.874 9.626 21.5 21.5 21.5 9.847 0 18.364-6.675 20.809-16.072a1.5 1.5 0 0 0-2.904-.756C37.803 34.755 30.473 40.5 22 40.5 11.783 40.5 3.5 32.217 3.5 22c0-8.137 5.3-15.247 12.942-17.65a1.5 1.5 0 1 0-.9-2.863z\" />"};

var spinnerSVGSmall = {"viewBox":"0 0 20 20","body":"<path d=\"M7.229 1.173a9.25 9.25 0 1 0 11.655 11.412 1.25 1.25 0 1 0-2.4-.698 6.75 6.75 0 1 1-8.506-8.329 1.25 1.25 0 1 0-.75-2.385z\" />"};

const COLORS_FOR_LARGE_SPINNER = ['teal', 'inkLightest'];
function Spinner$1({ size = 'large', color = 'teal', accessibilityLabel }) {
    if (size === 'large' && COLORS_FOR_LARGE_SPINNER.indexOf(color) < 0) {
        if (process.env.NODE_ENV === 'development') {
            // eslint-disable-next-line no-console
            console.warn(`The color ${color} is not meant to be used on ${size} spinners. The colors available on large spinners are: ${COLORS_FOR_LARGE_SPINNER.join(', ')}`);
        }
        // eslint-disable-next-line no-param-reassign
        size = 'small';
    }
    const className = classNames(styles$3.Spinner, color && styles$3[variationName('color', color)], size && styles$3[variationName('size', size)]);
    const spinnerSVG = size === 'large' ? spinnerSVGLarge : spinnerSVGSmall;
    return createElement('svg', { viewBox: spinnerSVG.viewBox, dangerouslySetInnerHTML: { __html: spinnerSVG.body }, className: className, 'aria-label': accessibilityLabel, role: 'status' });
}

var styles$4 = {
  "Button": "p_mh",
  "disabled": "p_ot",
  "Content": "p_wo",
  "Icon": "p_rw",
  "Spinner": "p_np",
  "primary": "p_b5",
  "destructive": "p_md",
  "outline": "p_qp",
  "loading": "p_fe",
  "plain": "p_ss",
  "fullWidth": "p_gj",
  "sizeSlim": "p_k5",
  "sizeLarge": "p_ro",
  "iconOnly": "p_yd",
  "skeletonShimmerAnimation": "p_pm",
};

function Button$1({ url, disabled, loading, children, accessibilityLabel, ariaControls, ariaExpanded, onClick, onFocus, onBlur, external, icon, primary, outline, destructive, disclosure, plain, submit, size, fullWidth }) {
  const isDisabled = disabled || loading;
  const className = classNames$1(styles$4.Button, primary && styles$4.primary, outline && styles$4.outline, destructive && styles$4.destructive, isDisabled && styles$4.disabled, loading && styles$4.loading, plain && styles$4.plain, size && styles$4[variationName$1('size', size)], fullWidth && styles$4.fullWidth, icon && children == null && styles$4.iconOnly);
  const disclosureIconMarkup = disclosure ? createElement(
    'span',
    { className: styles$4.Icon },
    createElement(Icon$1, { source: loading ? 'placeholder' : 'caretDown' })
  ) : null;
  const iconMarkup = icon ? createElement(
    'span',
    { className: styles$4.Icon },
    createElement(Icon$1, { source: loading ? 'placeholder' : icon })
  ) : null;
  const childMarkup = children ? createElement(
    'span',
    null,
    children
  ) : null;
  const spinnerColor = primary || destructive ? 'white' : 'inkLightest';
  const spinnerSVGMarkup = loading ? createElement(
    'span',
    { className: styles$4.Spinner },
    createElement(Spinner$1, { size: 'small', color: spinnerColor, accessibilityLabel: 'Loading' })
  ) : null;
  const content = iconMarkup || disclosureIconMarkup ? createElement(
    'span',
    { className: styles$4.Content },
    spinnerSVGMarkup,
    iconMarkup,
    childMarkup,
    disclosureIconMarkup
  ) : createElement(
    'span',
    { className: styles$4.Content },
    spinnerSVGMarkup,
    childMarkup
  );
  const type = submit ? 'submit' : 'button';
  return url ? createElement(
    UnstyledLink$1,
    { url: url, external: external, onClick: onClick, onFocus: onFocus, onBlur: onBlur, onMouseUp: handleMouseUpByBlurring, className: className, disabled: isDisabled, 'aria-label': accessibilityLabel },
    content
  ) : createElement(
    'button',
    { type: type, onClick: onClick, onFocus: onFocus, onBlur: onBlur, onMouseUp: handleMouseUpByBlurring, className: className, disabled: isDisabled, 'aria-label': accessibilityLabel, 'aria-controls': ariaControls, 'aria-expanded': ariaExpanded, role: loading ? 'alert' : undefined, 'aria-busy': loading ? true : undefined },
    content
  );
}
function buttonsFrom(actions, overrides = {}) {
  if (Array.isArray(actions)) {
    return actions.map((action, index) => buttonFrom(action, overrides, index));
  } else {
    const action = actions;
    return buttonFrom(action, overrides);
  }
}
function buttonFrom(_a, overrides, key) {
  var { content, onAction } = _a,
      action = __rest(_a, ["content", "onAction"]);
  return createElement(
    Button$1,
    Object.assign({ key: key, onClick: onAction }, action, overrides),
    content
  );
}

var styles$5 = {
  "ButtonGroup": "p_s0",
  "segmented": "p_i8",
  "Item": "p_yv",
  "Item-focused": "p_wl",
  "Item-plain": "p_h2",
  "skeletonShimmerAnimation": "p_rz",
};

class Item extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = { focused: false };
    }
    render() {
        const { button } = this.props;
        const { focused } = this.state;
        const className = classNames(styles$5.Item, focused && styles$5['Item-focused'], button.props.plain && styles$5['Item-plain']);
        return createElement(
            'div',
            { className: className, onFocus: this.handleFocus, onBlur: this.handleBlur },
            button
        );
    }
    handleFocus() {
        this.setState({ focused: true });
    }
    handleBlur() {
        this.setState({ focused: false });
    }
}
__decorate([autobind], Item.prototype, "handleFocus", null);
__decorate([autobind], Item.prototype, "handleBlur", null);

function ButtonGroup$1({ children, segmented }) {
    const className = classNames(styles$5.ButtonGroup, segmented && styles$5.segmented);
    const contents = elementChildren(children).map((child, index) => createElement(Item, { button: child, key: index }));
    return createElement(
        'div',
        { className: className },
        contents
    );
}

var styles$6 = {
  "Stack": "p_gz",
  "Item": "p_v0",
  "noWrap": "p_kf",
  "vertical": "p_zw",
  "spacingNone": "p_db",
  "spacingExtraTight": "p_up",
  "spacingTight": "p_qt",
  "spacingLoose": "p_so",
  "spacingExtraLoose": "p_pz",
  "distributionLeading": "p_fq",
  "distributionTrailing": "p_h1",
  "distributionCenter": "p_tw",
  "distributionEqualSpacing": "p_lk",
  "distributionFill": "p_c4",
  "distributionFillEvenly": "p_m4",
  "alignmentLeading": "p_if",
  "alignmentTrailing": "p_ni",
  "alignmentCenter": "p_le",
  "alignmentFill": "p_ef",
  "alignmentBaseline": "p_id",
  "Item-fill": "p_eg",
  "skeletonShimmerAnimation": "p_iz",
};

function Item$1({ children, fill }) {
    const className = classNames(styles$6.Item, fill && styles$6['Item-fill']);
    return createElement(
        'div',
        { className: className },
        children
    );
}

class Stack$1 extends PureComponent {
    render() {
        const { children, vertical, spacing, distribution, alignment, wrap } = this.props;
        const className = classNames(styles$6.Stack, vertical && styles$6.vertical, spacing && styles$6[variationName('spacing', spacing)], distribution && styles$6[variationName('distribution', distribution)], alignment && styles$6[variationName('alignment', alignment)], wrap === false && styles$6.noWrap);
        const itemMarkup = elementChildren(children).map((child, index) => {
            const props = { key: index };
            return wrapWithComponent(child, Item$1, props);
        });
        return createElement(
            'div',
            { className: className },
            itemMarkup
        );
    }
}
Stack$1.Item = Item$1;

var styles$7 = {
  "Heading": "p_y9",
  "skeletonShimmerAnimation": "p_me",
};

function Heading$1({ element: Element = 'h2', children }) {
    return createElement(
        Element,
        { className: styles$7.Heading },
        children
    );
}

var styles$8 = {
  "Card": "p_c2",
  "subdued": "p_vp",
  "Header": "p_o5",
  "Section": "p_z4",
  "Section-subdued": "p_pb",
  "SectionHeader": "p_sc",
  "Footer": "p_n7",
  "skeletonShimmerAnimation": "p_m3",
};

function Header({ children, actions }) {
  const actionMarkup = actions ? createElement(
    ButtonGroup$1,
    null,
    buttonsFrom(actions, { plain: true })
  ) : null;
  const headingMarkup = actionMarkup ? createElement(
    Stack$1,
    { alignment: 'baseline' },
    createElement(
      Stack$1.Item,
      { fill: true },
      createElement(
        Heading$1,
        null,
        children
      )
    ),
    actionMarkup
  ) : createElement(
    Heading$1,
    null,
    children
  );
  return createElement(
    'div',
    { className: styles$8.Header },
    headingMarkup
  );
}

var styles$9 = {
  "Subheading": "p_xf",
  "skeletonShimmerAnimation": "p_vh",
};

function Subheading$1({ element: Element = 'h3', children }) {
    const ariaLabel = typeof children === 'string' ? children : null;
    return createElement(
        Element,
        { 'aria-label': ariaLabel, className: styles$9.Subheading },
        children
    );
}

function Section({ children, title, subdued }) {
  const headerContent = title ? createElement(
    'div',
    { className: styles$8.SectionHeader },
    createElement(
      Subheading$1,
      null,
      title
    )
  ) : null;
  const className = classNames(styles$8.Section, subdued && styles$8['Section-subdued']);
  return createElement(
    'div',
    { className: className },
    headerContent,
    children
  );
}

class Card$1 extends PureComponent {
    render() {
        const { children, title, subdued, sectioned, actions, primaryFooterAction, secondaryFooterAction } = this.props;
        const className = classNames(styles$8.Card, subdued && styles$8.subdued);
        const headerMarkup = title ? createElement(
            Header,
            { actions: actions },
            title
        ) : null;
        const content = sectioned ? createElement(
            Section,
            null,
            children
        ) : children;
        const primaryFooterActionMarkup = primaryFooterAction ? buttonFrom(primaryFooterAction, { primary: true }) : null;
        const secondaryFooterActionMarkup = secondaryFooterAction ? buttonFrom(secondaryFooterAction) : null;
        const footerMarkup = primaryFooterActionMarkup || secondaryFooterActionMarkup ? createElement(
            'div',
            { className: styles$8.Footer },
            createElement(
                ButtonGroup$1,
                null,
                primaryFooterActionMarkup,
                secondaryFooterActionMarkup
            )
        ) : null;
        return createElement(
            'div',
            { className: className },
            headerMarkup,
            content,
            footerMarkup
        );
    }
}
Card$1.Section = Section;

var styles$10 = {
  "SettingAction": "p_ts",
  "Setting": "p_ce",
  "Action": "p_rh",
  "skeletonShimmerAnimation": "p_fg",
};

function SettingAction$1({ action, children }) {
  return createElement(
    'div',
    { className: styles$10.SettingAction },
    createElement(
      'div',
      { className: styles$10.Setting },
      children
    ),
    createElement(
      'div',
      { className: styles$10.Action },
      action
    )
  );
}

var styles$11 = {
  "variationPositive": "p_w5",
  "variationNegative": "p_pv",
  "variationStrong": "p_sg",
  "variationSubdued": "p_ma",
  "skeletonShimmerAnimation": "p_lu",
};

function TextStyle$1({ variation, children }) {
    const className = classNames(variation && styles$11[variationName('variation', variation)]);
    return createElement(
        'span',
        { className: className },
        children
    );
}

var styles$12 = {
  "TermsOfService": "p_az",
  "Content": "p_qj",
  "skeletonShimmerAnimation": "p_ec",
};

function AccountConnection$1({ connected = false, action, avatarUrl, accountName = '', title, details, termsOfService }) {
    const initials = accountName ? accountName.split(/\s+/).map(name => name[0]).join('') : undefined;
    const avatarMarkup = connected ? createElement(Avatar$1, { accessibilityLabel: '', name: accountName, initials: initials, source: avatarUrl }) : null;
    let titleMarkup = null;
    if (title) {
        titleMarkup = createElement(
            'div',
            null,
            title
        );
    } else if (accountName) {
        titleMarkup = createElement(
            'div',
            null,
            accountName
        );
    }
    const detailsMarkup = details ? createElement(
        'div',
        null,
        createElement(
            TextStyle$1,
            { variation: 'subdued' },
            details
        )
    ) : null;
    const termsOfServiceMarkup = termsOfService ? createElement(
        'div',
        { className: styles$12.TermsOfService },
        termsOfService
    ) : null;
    const actionElement = action ? buttonFrom(action, { primary: !connected }) : null;
    return createElement(
        Card$1,
        { sectioned: true },
        createElement(
            SettingAction$1,
            { action: actionElement },
            createElement(
                Stack$1,
                null,
                avatarMarkup,
                createElement(
                    Stack$1.Item,
                    { fill: true },
                    createElement(
                        'div',
                        { className: styles$12.Content },
                        titleMarkup,
                        detailsMarkup
                    )
                )
            )
        ),
        termsOfServiceMarkup
    );
}

var styles$13 = {
  "ActionList": "p_rp",
  "Section-withoutTitle": "p_ay",
  "Actions": "p_n9",
  "Title": "p_h9",
  "Item": "p_v6",
  "Image": "p_la",
  "disabled": "p_ge",
  "Content": "p_mu",
  "Text": "p_ap",
  "skeletonShimmerAnimation": "p_k3",
};

function Item$2({ content, url, onAction, icon, image, disabled, external }) {
  const className = classNames$1(styles$13.Item, disabled && styles$13.disabled);
  let imageElement = null;
  if (icon) {
    imageElement = createElement(
      'div',
      { className: styles$13.Image },
      createElement(Icon$1, { source: icon })
    );
  } else if (image) {
    imageElement = createElement('div', { role: 'presentation', className: styles$13.Image, style: { backgroundImage: `url(${image}` } });
  }
  const contentElement = imageElement ? createElement(
    'div',
    { className: styles$13.Content },
    imageElement,
    createElement(
      'div',
      { className: styles$13.Text },
      content
    )
  ) : content;
  const control = url ? createElement(
    UnstyledLink$1,
    { url: url, onClick: onAction, className: styles$13.Item, external: external },
    contentElement
  ) : createElement(
    'button',
    { onClick: onAction, className: className, disabled: disabled },
    contentElement
  );
  return createElement(
    'li',
    null,
    control
  );
}

function Section$1({ section, hasMultipleSections, onActionAnyItem }) {
    const handleAction = itemOnAction => {
        return () => {
            if (itemOnAction) {
                itemOnAction();
            }
            if (onActionAnyItem) {
                onActionAnyItem();
            }
        };
    };
    const actionMarkup = section.items.map((_a, index) => {
        var { content, onAction } = _a,
            item = __rest(_a, ["content", "onAction"]);
        return createElement(Item$2, Object.assign({ key: `${content}-${index}`, content: content, onAction: handleAction(onAction) }, item));
    });
    const className = section.title ? null : styles$13['Section-withoutTitle'];
    const titleMarkup = section.title ? createElement(
        'p',
        { className: styles$13.Title },
        section.title
    ) : null;
    const sectionMarkup = createElement(
        'div',
        { className: className },
        titleMarkup,
        createElement(
            'ul',
            { className: styles$13.Actions },
            actionMarkup
        )
    );
    return hasMultipleSections ? createElement(
        'li',
        null,
        sectionMarkup
    ) : sectionMarkup;
}

function ActionList$1({ items, sections = [], onActionAnyItem }) {
    let finalSections = [];
    if (items) {
        finalSections = [{ items }, ...sections];
    } else if (sections) {
        finalSections = sections;
    }
    const hasMultipleSections = finalSections.length > 1;
    const Element = hasMultipleSections ? 'ul' : 'div';
    const sectionMarkup = finalSections.map((section, index) => {
        return createElement(Section$1, { key: section.title || index, section: section, onActionAnyItem: onActionAnyItem, hasMultipleSections: hasMultipleSections });
    });
    return createElement(
        Element,
        { className: styles$13.ActionList },
        sectionMarkup
    );
}

var styles$14 = {
  "VisuallyHidden": "p_wk",
  "skeletonShimmerAnimation": "p_zn",
};

function VisuallyHidden$1({ children }) {
    return createElement(
        'span',
        { className: styles$14.VisuallyHidden },
        children
    );
}

var styles$15 = {
  "Badge": "p_xm",
  "Pip": "p_b1",
  "statusSuccess": "p_zl",
  "statusInfo": "p_kq",
  "statusAttention": "p_ys",
  "statusWarning": "p_jo",
  "progressIncomplete": "p_ok",
  "progressPartiallyComplete": "p_bs",
  "progressComplete": "p_hs",
  "skeletonShimmerAnimation": "p_ha",
};

const PROGRESS_LABELS = {
    incomplete: 'Incomplete',
    partiallyComplete: 'Partially complete',
    complete: 'Complete'
};
const STATUS_LABELS = {
    info: 'Info',
    success: 'Success',
    warning: 'Warning',
    attention: 'Attention'
};
function Badge$1({ children, status, progress }) {
    const className = classNames(styles$15.Badge, status && styles$15[variationName('status', status)], progress && styles$15[variationName('progress', progress)]);
    const pipMarkup = progress ? createElement(
        'span',
        { className: styles$15.Pip },
        createElement(
            VisuallyHidden$1,
            null,
            PROGRESS_LABELS[progress]
        )
    ) : null;
    const statusLabelMarkup = status ? createElement(
        VisuallyHidden$1,
        null,
        STATUS_LABELS[status]
    ) : null;
    return createElement(
        'span',
        { className: className },
        statusLabelMarkup,
        pipMarkup,
        children
    );
}

var styles$16 = {
  "Banner": "p_wi",
  "hasDismiss": "p_zh",
  "statusSuccess": "p_kg",
  "statusInfo": "p_h7",
  "statusWarning": "p_o8",
  "statusCritical": "p_pu",
  "Ribbon": "p_se",
  "Heading": "p_hd",
  "Actions": "p_sp",
  "Content": "p_w0",
  "SecondaryAction": "p_e3",
  "Text": "p_x9",
  "Dismiss": "p_kt",
  "skeletonShimmerAnimation": "p_dr",
};

var successIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m2.293-10.707L9 10.586 7.707 9.293a1 1 0 1 0-1.414 1.414l2 2a.997.997 0 0 0 1.414 0l4-4a1 1 0 1 0-1.414-1.414\" /></g>"};

var fallbackIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><path fill=\"currentColor\" d=\"M2 3h11v4h6l-2 4 2 4H8v-4H3\"/><path d=\"M16.105 11.447L17.381 14H9v-2h4a1 1 0 0 0 1-1V8h3.38l-1.274 2.552a.993.993 0 0 0 0 .895zM2.69 4H12v6H4.027L2.692 4zm15.43 7l1.774-3.553A1 1 0 0 0 19 6h-5V3c0-.554-.447-1-1-1H2.248L1.976.782a1 1 0 1 0-1.953.434l4 18a1.006 1.006 0 0 0 1.193.76 1 1 0 0 0 .76-1.194L4.47 12H7v3a1 1 0 0 0 1 1h11c.346 0 .67-.18.85-.476a.993.993 0 0 0 .044-.972l-1.775-3.553z\" /></g>"};

var warningIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-13a1 1 0 0 0-1 1v4a1 1 0 1 0 2 0V6a1 1 0 0 0-1-1m0 8a1 1 0 1 0 0 2 1 1 0 0 0 0-2\" /></g>"};

var criticalIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle fill=\"currentColor\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M2 10c0-1.846.635-3.543 1.688-4.897l11.209 11.209A7.954 7.954 0 0 1 10 18c-4.411 0-8-3.589-8-8m14.312 4.897L5.103 3.688A7.954 7.954 0 0 1 10 2c4.411 0 8 3.589 8 8a7.952 7.952 0 0 1-1.688 4.897M0 10c0 5.514 4.486 10 10 10s10-4.486 10-10S15.514 0 10 0 0 4.486 0 10\" /></g>"};

var infoIcon = {"viewBox":"0 0 20 20","body":"<g  fill-rule=\"evenodd\"><circle cx=\"10\" cy=\"10\" r=\"9\" fill=\"currentColor\"/><path  d=\"M10 0C4.486 0 0 4.486 0 10s4.486 10 10 10 10-4.486 10-10S15.514 0 10 0m0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8m1-5v-3a1 1 0 0 0-1-1H9a1 1 0 1 0 0 2v3a1 1 0 0 0 1 1h1a1 1 0 1 0 0-2m-1-5.9a1.1 1.1 0 1 0 0-2.2 1.1 1.1 0 0 0 0 2.2\"/></g>"};

function Banner$1({ icon, action, secondaryAction, title, children, status, onDismiss }) {
    let color;
    let defaultIcon;
    let ariaRoleType = 'status';
    switch (status) {
        case 'success':
            color = 'greenDark';
            defaultIcon = successIcon;
            break;
        case 'info':
            color = 'tealDark';
            defaultIcon = infoIcon;
            break;
        case 'warning':
            color = 'yellowDark';
            defaultIcon = warningIcon;
            ariaRoleType = 'alert';
            break;
        case 'critical':
            color = 'redDark';
            defaultIcon = criticalIcon;
            ariaRoleType = 'alert';
            break;
        default:
            color = 'inkLighter';
            defaultIcon = fallbackIcon;
    }
    const className = classNames(styles$16.Banner, status && styles$16[variationName('status', status)], onDismiss && styles$16.hasDismiss);
    const id = uniqueID();
    const iconName = icon || defaultIcon;
    let headingMarkup = null;
    let headingID;
    if (title) {
        headingID = `${id}Heading`;
        headingMarkup = createElement(
            'div',
            { className: styles$16.Heading, id: headingID },
            createElement(
                Heading$1,
                { element: 'p' },
                title
            )
        );
    }
    const secondaryActionMarkup = secondaryAction ? secondaryActionFrom(secondaryAction) : null;
    const actionMarkup = action ? createElement(
        'div',
        { className: styles$16.Actions },
        createElement(
            ButtonGroup$1,
            null,
            buttonFrom(action, { outline: true }),
            secondaryActionMarkup
        )
    ) : null;
    let contentMarkup = null;
    let contentID;
    if (children || actionMarkup) {
        contentID = `${id}Content`;
        contentMarkup = createElement(
            'div',
            { className: styles$16.Content, id: contentID },
            children,
            actionMarkup
        );
    }
    const dismissButton = onDismiss ? createElement(
        'div',
        { className: styles$16.Dismiss },
        createElement(Button$1, { plain: true, icon: 'cancelSmall', onClick: onDismiss, accessibilityLabel: 'Dismiss notification' })
    ) : null;
    return createElement(
        'div',
        { className: className
            // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
            , tabIndex: 0, role: ariaRoleType, 'aria-live': 'polite', onMouseUp: handleMouseUp, 'aria-labelledby': headingID, 'aria-describedby': contentID },
        dismissButton,
        createElement(
            'div',
            { className: styles$16.Ribbon },
            createElement(Icon$1, { source: iconName, color: color, backdrop: true })
        ),
        createElement(
            'div',
            null,
            headingMarkup,
            contentMarkup
        )
    );
}
let index = 1;
function uniqueID() {
    return `Banner${index++}`;
}
function handleMouseUp({ currentTarget }) {
    currentTarget.blur();
}
function secondaryActionFrom(action) {
    if (action.url) {
        return createElement(
            UnstyledLink$1,
            { className: styles$16.SecondaryAction, url: action.url },
            createElement(
                'span',
                { className: styles$16.Text },
                action.content
            )
        );
    }
    return createElement(
        'button',
        { className: styles$16.SecondaryAction, onClick: action.onAction },
        createElement(
            'span',
            { className: styles$16.Text },
            action.content
        )
    );
}

var styles$17 = {
  "TextContainer": "p_jx",
  "spacingTight": "p_h4",
  "spacingLoose": "p_qf",
  "skeletonShimmerAnimation": "p_vt",
};

function TextContainer$1({ spacing, children }) {
    const className = classNames(styles$17.TextContainer, spacing && styles$17[variationName('spacing', spacing)]);
    return createElement(
        'div',
        { className: className },
        children
    );
}

var styles$18 = {
  "CalloutCard": "p_ix",
  "Image": "p_wz",
  "Content": "p_ye",
  "Title": "p_v4",
  "Buttons": "p_fl",
  "skeletonShimmerAnimation": "p_yx",
};

function CalloutCard$1({ title, children, illustration, primaryAction, secondaryAction }) {
  const primaryActionMarkup = buttonFrom(primaryAction);
  const secondaryActionMarkup = secondaryAction ? buttonFrom(secondaryAction, { plain: true }) : null;
  const buttonMarkup = secondaryActionMarkup ? createElement(
    ButtonGroup$1,
    null,
    primaryActionMarkup,
    secondaryActionMarkup
  ) : primaryActionMarkup;
  return createElement(
    Card$1,
    { sectioned: true },
    createElement(
      'div',
      { className: styles$18.CalloutCard },
      createElement(
        'div',
        { className: styles$18.Content },
        createElement(
          'div',
          { className: styles$18.Title },
          createElement(
            Heading$1,
            null,
            title
          )
        ),
        createElement(
          TextContainer$1,
          null,
          children
        ),
        createElement(
          'div',
          { className: styles$18.Buttons },
          buttonMarkup
        )
      ),
      createElement(Image$1, { alt: '', className: styles$18.Image, source: illustration })
    )
  );
}

var styles$19 = {
  "Caption": "p_r1",
  "skeletonShimmerAnimation": "p_gn",
};

function Caption$1({ children }) {
    return createElement(
        'p',
        { className: styles$19.Caption },
        children
    );
}

var styles$20 = {
  "Choice": "p_pr",
  "labelHidden": "p_hx",
  "Label": "p_e2",
  "Control": "p_is",
  "Descriptions": "p_om",
  "HelpText": "p_g6",
  "Error": "p_st",
  "ErrorIcon": "p_m0",
  "skeletonShimmerAnimation": "p_jn",
};

function Choice$1({ id, label, error, children, labelHidden, helpText }) {
  const className = classNames(styles$20.Choice, labelHidden && styles$20.labelHidden);
  const labelMarkup = createElement(
    'label',
    { className: className, htmlFor: id },
    createElement(
      'span',
      { className: styles$20.Control },
      children
    ),
    createElement(
      'span',
      { className: styles$20.Label },
      label
    )
  );
  const helpTextMarkup = helpText ? createElement(
    'div',
    { className: styles$20.HelpText, id: helpTextID(id) },
    helpText
  ) : null;
  const errorMarkup = typeof error === 'string' ? createElement(
    'div',
    { className: styles$20.Error, id: errorID(id) },
    createElement(
      'div',
      { className: styles$20.ErrorIcon },
      createElement(Icon$1, { source: 'alert' })
    ),
    error
  ) : null;
  const descriptionMarkup = helpTextMarkup || errorMarkup ? createElement(
    'div',
    { className: styles$20.Descriptions },
    errorMarkup,
    helpTextMarkup
  ) : null;
  return descriptionMarkup ? createElement(
    'div',
    null,
    labelMarkup,
    descriptionMarkup
  ) : labelMarkup;
}
function helpTextID(id) {
  return `${id}HelpText`;
}
function errorID(id) {
  return `${id}Error`;
}

var styles$21 = {
  "Checkbox": "p_oj",
  "error": "p_x0",
  "Input": "p_hm",
  "Backdrop": "p_vn",
  "Input-indeterminate": "p_wy",
  "Icon": "p_lz",
  "skeletonShimmerAnimation": "p_fh",
};

const getUniqueID = createUniqueIDFactory('Checkbox');
function Checkbox$1({ id = getUniqueID(), label, labelHidden, helpText, checked = false, error, disabled, onChange, onFocus, onBlur, name, value }) {
    function handleChange(event) {
        if (onChange == null) {
            return;
        }
        const { currentTarget } = event;
        onChange(currentTarget.checked, id);
    }
    const describedBy = [];
    if (typeof error === 'string') {
        describedBy.push(errorID(id));
    }
    if (helpText) {
        describedBy.push(helpTextID(id));
    }
    const ariaDescribedBy = describedBy.length ? describedBy.join(' ') : undefined;
    const wrapperClassName = classNames(styles$21.Checkbox, error && styles$21.error);
    const isIndeterminate = checked === 'indeterminate';
    const isChecked = !isIndeterminate && Boolean(checked);
    const indeterminateAttributes = isIndeterminate ? { indeterminate: 'true', 'aria-checked': 'mixed' } : { 'aria-checked': isChecked };
    const iconSource = isIndeterminate ? 'subtract' : 'checkmark';
    const inputClassName = classNames(styles$21.Input, isIndeterminate && styles$21['Input-indeterminate']);
    return (
        /* eslint-disable jsx-a11y/no-redundant-roles, jsx-a11y/role-has-required-aria-props */
        createElement(
            Choice$1,
            { id: id, label: label, labelHidden: labelHidden, helpText: helpText, error: error },
            createElement(
                'div',
                { className: wrapperClassName },
                createElement('input', Object.assign({ id: id, name: name, value: value, type: 'checkbox', checked: isChecked, disabled: disabled, className: inputClassName, onChange: handleChange, onFocus: onFocus, onBlur: onBlur, 'aria-invalid': error != null, 'aria-describedby': ariaDescribedBy, role: 'checkbox' }, indeterminateAttributes)),
                createElement('div', { className: styles$21.Backdrop }),
                createElement(
                    'div',
                    { className: styles$21.Icon },
                    createElement(Icon$1, { source: iconSource })
                )
            )
        )
    );
}

var styles$22 = {
  "RadioButton": "p_cz",
  "Input": "p_br",
  "Backdrop": "p_tt",
  "Icon": "p_bc",
  "skeletonShimmerAnimation": "p_un",
};

const getUniqueID$2 = createUniqueIDFactory('RadioButton');
function RadioButton$1({ label, labelHidden, helpText, checked, disabled, onChange, onFocus, onBlur, id = getUniqueID$2(), name = id, value }) {
    function handleChange({ currentTarget }) {
        if (onChange == null) {
            return;
        }
        onChange(currentTarget.checked, id);
    }
    const describedBy = helpText ? helpTextID(id) : null;
    return createElement(
        Choice$1,
        { label: label, labelHidden: labelHidden, id: id, helpText: helpText },
        createElement(
            'div',
            { className: styles$22.RadioButton },
            createElement('input', { id: id, name: name, value: value, type: 'radio', checked: checked, disabled: disabled, className: styles$22.Input, onChange: handleChange, onFocus: onFocus, onBlur: onBlur, 'aria-describedby': describedBy }),
            createElement('div', { className: styles$22.Backdrop }),
            createElement('div', { className: styles$22.Icon })
        )
    );
}

var styles$23 = {
  "ChoiceList": "p_nc",
  "titleHidden": "p_bl",
  "Title": "p_nt",
  "Choices": "p_fz",
  "ChoiceChildren": "p_bq",
  "skeletonShimmerAnimation": "p_vq",
};

const getUniqueID$1 = createUniqueIDFactory('ChoiceList');
function ChoiceList$1({ title, titleHidden, allowMultiple, choices, selected, onChange = noop, name = getUniqueID$1() }) {
    const ControlComponent = allowMultiple ? Checkbox$1 : RadioButton$1;
    const finalName = allowMultiple ? `${name}[]` : name;
    const className = classNames(styles$23.ChoiceList, titleHidden && styles$23.titleHidden);
    const titleMarkup = title ? createElement(
        'legend',
        { className: styles$23.Title },
        title
    ) : null;
    const choicesMarkup = choices.map(choice => {
        const { value, label, helpText, disabled } = choice;
        function handleChange(checked) {
            onChange(updateSelectedChoices(choice, checked, selected, allowMultiple), name);
        }
        const isSelected = choiceIsSelected(choice, selected);
        const children = choice.renderChildren ? createElement(
            'div',
            { className: styles$23.ChoiceChildren },
            choice.renderChildren(isSelected)
        ) : null;
        return createElement(
            'li',
            { key: value },
            createElement(ControlComponent, { name: finalName, value: value, label: label, disabled: disabled, checked: choiceIsSelected(choice, selected), helpText: helpText, onChange: handleChange }),
            children
        );
    });
    return createElement(
        'fieldset',
        { className: className },
        titleMarkup,
        createElement(
            'ul',
            { className: styles$23.Choices },
            choicesMarkup
        )
    );
}
function choiceIsSelected({ value }, selected) {
    return selected.indexOf(value) >= 0;
}
function updateSelectedChoices({ value }, checked, selected, allowMultiple = false) {
    if (checked) {
        return allowMultiple ? [...selected, value] : [value];
    }
    return selected.filter(selectedChoice => selectedChoice !== value);
}

var name = "@shopify/polaris";
var description = "Shopify’s product component library";
var version = "1.14.1";
var license = "MIT";
var author = "Shopify <dev@shopify.com>";
var homepage = "https://github.com/Shopify/polaris#readme";
var repository = "https://github.com/Shopify/polaris";
var bugs = {"url":"https://github.com/Shopify/polaris/issues"};
var publishConfig = {"access":"public"};
var keywords = ["shopify","polaris","react","components","component library"];
var main = "index.js";
var module$1 = "index.es.js";
var types = "types/index.d.ts";
var scripts = {"lint:js":"eslint './src/**/*.{ts,tsx}' --max-warnings 0 --format codeframe","lint:fix":"eslint './src/**/*.{ts,tsx}' --fix --max-warnings 0 --format codeframe","lint":"npm-run-all lint:js","ts":"tsc --noEmit","test":"jest --config ./config/jest/config.json","test:ci":"yarn run test -- --runInBand","test:watch":"yarn run test -- --watch","check":"npm-run-all lint ts test","check:ci":"npm-run-all lint ts test:ci","clean":"rimraf build build-esnext esnext styles types docs 'build-intermediate' 'index.*' 'embedded.js' 'styles.{css,scss}'","optimize":"node ./scripts/optimize.js","prebuild":"npm-run-all clean optimize","build":"babel-node ./scripts/build.js","prebuild-consumer":"npm-run-all build hide-private-readme","build-consumer":"babel-node ./scripts/build-consumer","postbuild-consumer":"yarn run show-private-readme","precdn":"yarn run build","cdn:secrets":"ejson decrypt -o secrets.json secrets.ejson","cdn:deploy":"node ./scripts/deploy.js","cdn":"npm-run-all cdn:secrets cdn:deploy","public-release:secrets":"ejson decrypt -o secrets.json secrets.ejson","prepublic-release":"rimraf sandbox && yarn run public-release:secrets","public-release":"babel-node ./scripts/public-repo-deploy.js","hide-private-readme":"shx mv README.md ./public/README-private.md && shx mv ./public/README.md ./README.md","show-private-readme":"shx mv ./README.md ./public/README.md && shx mv ./public/README-private.md ./README.md ","prepublish":"in-publish && npm-run-all build hide-private-readme || :","postpublish":"in-publish && npm-run-all cdn show-private-readme public-release || :","dev":"webpack-dev-server --config playground/webpack.config.js --content-base playground/ --hot --inline","dev:host":"webpack-dev-server --config playground/webpack.config.js --content-base playground/ --hot --inline --host $(ipconfig getifaddr en0)","start":"echo \"Warning: no 'start' task specified. Run 'yarn dev' instead.\" && yarn dev"};
var devDependencies = {"@shopify/js-uploader":"github:Shopify/js-uploader","@types/enzyme":"^2.8.12","@types/jest":"^21.1.2","@types/lodash":"^4.14.66","@types/node":"^8.0.0","@types/react-hot-loader":"^3.0.1","archiver":"^2.1.0","awesome-typescript-loader":"^3.1.3","aws-sdk":"^2.58.0","babel-cli":"^6.26.0","babel-core":"^6.26.0","babel-jest":"^21.2.0","babel-loader":"^7.1.2","babel-preset-shopify":"^16.2.0","change-case":"^3.0.1","copyfiles":"^1.2.0","crypto":"^1.0.1","css-loader":"^0.28.3","cssnano":"^3.10.0","enzyme":"^3.1.0","enzyme-adapter-react-16":"^1.0.1","eslint":"^4.8.0","eslint-plugin-shopify":"^19.0.0","file-loader":"^1.1.5","fs-extra":"^4.0.2","generic-names":"^1.0.2","glob":"^7.1.2","identity-obj-proxy":"^3.0.0","image-webpack-loader":"^3.3.1","in-publish":"^2.0.0","jest":"^21.2.1","node-sass":"^4.5.3","npm-run-all":"^4.0.2","postcss":"^6.0.1","postcss-loader":"^2.0.5","postcss-modules-extract-imports":"^1.1.0","postcss-modules-local-by-default":"^1.2.0","postcss-modules-parser":"^1.1.1","postcss-modules-scope":"^1.1.0","postcss-modules-values":"^1.3.0","postcss-shopify":"^1.0.0","react":"^16.0.0","react-dom":"^16.0.0","react-test-renderer":"^16.0.0","rimraf":"^2.6.1","rollup":"^0.50.0","rollup-plugin-babel":"^3.0.2","rollup-plugin-commonjs":"^8.0.2","rollup-plugin-json":"^2.1.1","rollup-plugin-node-resolve":"^3.0.0","rollup-pluginutils":"^2.0.1","sass-loader":"^6.0.6","sass-resources-loader":"^1.2.1","semver":"^5.4.1","shelljs":"^0.7.7","shx":"^0.2.2","style-loader":"^0.19.0","svgo":"^0.7.2","tslint":"^5.8.0","typescript":"^2.5.3","url-loader":"^0.6.2","webpack":"^3.7.1","webpack-dev-server":"^2.9.3"};
var peerDependencies = {"react":"^15.3.0 || ^16.0.0","react-dom":"^15.3.0 || ^16.0.0"};
var files = ["esnext","styles","types","docs","index.js","index.es.js","styles.css","styles.scss","embedded.js","embedded.d.ts"];
var dependencies = {"@shopify/images":"^1.1.0","@shopify/javascript-utilities":"^2.1.0","@shopify/react-utilities":"2.0.0-beta.9","@types/prop-types":"^15.5.2","@types/react":"^16.0.2","@types/react-dom":"^16.0.2","@types/react-transition-group":"^2.0.6","babel-runtime":"^6.23.0","core-js":"^2.5.1","hoist-non-react-statics":"^2.3.1","lodash":"^4.17.4","prop-types":"^15.6.0","react-transition-group":"^2.2.1","tslib":"^1.8.0"};
var pkg = {
	name: name,
	description: description,
	version: version,
	license: license,
	author: author,
	homepage: homepage,
	repository: repository,
	bugs: bugs,
	publishConfig: publishConfig,
	keywords: keywords,
	main: main,
	module: module$1,
	types: types,
	scripts: scripts,
	devDependencies: devDependencies,
	peerDependencies: peerDependencies,
	files: files,
	dependencies: dependencies,
	"private": false,
	"jsnext:main": "index.es.js"
};

var styles$24 = {
  "Collapsible": "p_lx",
  "animating": "p_uw",
  "open": "p_xj",
  "skeletonShimmerAnimation": "p_et",
};

const CONTEXT_TYPES = {
    parentCollapsibleExpanding: bool
};
class Collapsible$1 extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            height: null,
            animationState: 'idle'
        };
        this.node = null;
        this.heightNode = null;
    }
    getChildContext() {
        const { open } = this.props;
        const { animationState } = this.state;
        const { parentCollapsibleExpanding } = this.context;
        return {
            parentCollapsibleExpanding: parentCollapsibleExpanding || open && animationState !== 'idle'
        };
    }
    componentWillReceiveProps({ open: willOpen }) {
        const { open } = this.props;
        if (open !== willOpen) {
            this.setState({ animationState: 'measuring' });
        }
    }
    componentDidUpdate({ open: wasOpen }) {
        const { animationState } = this.state;
        const { parentCollapsibleExpanding } = this.context;
        if (parentCollapsibleExpanding && animationState !== 'idle') {
            this.setState({
                animationState: 'idle'
            });
            return;
        }
        read(() => {
            switch (animationState) {
                case 'idle':
                    break;
                case 'measuring':
                    this.setState({
                        animationState: wasOpen ? 'closingStart' : 'openingStart',
                        height: wasOpen && this.heightNode ? this.heightNode.scrollHeight : 0
                    });
                    break;
                case 'closingStart':
                    this.setState({
                        animationState: 'closing',
                        height: 0
                    });
                    break;
                case 'openingStart':
                    this.setState({
                        animationState: 'opening',
                        height: this.heightNode ? this.heightNode.scrollHeight : 0
                    });
            }
        });
    }
    componentDidMount() {
        if (this.node == null) {
            return;
        }
        addEventListener(this.node, 'transitionend', this.handleTransitionEnd);
    }
    componentWillUnmount() {
        if (this.node == null) {
            return;
        }
        removeEventListener(this.node, 'transitionend', this.handleTransitionEnd);
    }
    render() {
        const { id, open, children } = this.props;
        const { animationState, height } = this.state;
        const animating = animationState !== 'idle';
        const wrapperClassName = classNames(styles$24.Collapsible, open && styles$24.open, animating && styles$24.animating);
        const displayHeight = collapsibleHeight(open, animationState, height);
        const content = animating || open ? children : null;
        /* TODO before v2 release: remove this conditional and line 9 */
        if (!id && pkg.version[0] === '1') {
            /* eslint-disable no-console */
            console.group('Polaris');
            console.info(`You are currently using version ${pkg.version}.`);
            console.warn('[Deprecation] The new `id` prop on Collapsible will be required from version 2.0.0 onward.');
            console.groupEnd();
            /* eslint-enable no-console */
        }
        return createElement(
            'div',
            { id: id, 'aria-hidden': !open, style: { height: displayHeight }, className: wrapperClassName, ref: this.bindNode },
            createElement(
                'div',
                { ref: this.bindHeightNode },
                content
            )
        );
    }
    bindNode(node) {
        this.node = node;
    }
    bindHeightNode(node) {
        this.heightNode = node;
    }
    handleTransitionEnd(event) {
        const { target } = event;
        if (target === this.node) {
            this.setState({ animationState: 'idle', height: null });
        }
    }
}
Collapsible$1.contextTypes = CONTEXT_TYPES;
Collapsible$1.childContextTypes = CONTEXT_TYPES;
__decorate([autobind], Collapsible$1.prototype, "bindNode", null);
__decorate([autobind], Collapsible$1.prototype, "bindHeightNode", null);
__decorate([autobind], Collapsible$1.prototype, "handleTransitionEnd", null);
function collapsibleHeight(open, animationState, height) {
    if (animationState === 'idle' && open) {
        return open ? 'auto' : null;
    }
    if (animationState === 'measuring') {
        return open ? null : 'auto';
    }
    return `${height || 0}px`;
}

function rgbString(color) {
    const { red, green, blue } = color;
    if (color.hasOwnProperty('alpha')) {
        return `rgba(${red}, ${green}, ${blue}, ${color.alpha})`;
    } else {
        return `rgb(${red}, ${green}, ${blue})`;
    }
}
const rgbaString = rgbString;
function rgbToHex({ red, green, blue }) {
    return `#${componentToHex(red)}${componentToHex(green)}${componentToHex(blue)}`;
}
function componentToHex(component) {
    const hex = component.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
}
function hsbToHex(color) {
    return rgbToHex(hsbToRgb(color));
}
function hsbToRgb(color) {
    const { hue, saturation, brightness, alpha = 1 } = color;
    const chroma = brightness * saturation;
    const huePrime = hue / 60;
    const hueDelta = 1 - Math.abs(huePrime % 2 - 1);
    const intermediateValue = chroma * hueDelta;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (huePrime >= 0 && huePrime <= 1) {
        red = chroma;
        green = intermediateValue;
        blue = 0;
    }
    if (huePrime >= 1 && huePrime <= 2) {
        red = intermediateValue;
        green = chroma;
        blue = 0;
    }
    if (huePrime >= 2 && huePrime <= 3) {
        red = 0;
        green = chroma;
        blue = intermediateValue;
    }
    if (huePrime >= 3 && huePrime <= 4) {
        red = 0;
        green = intermediateValue;
        blue = chroma;
    }
    if (huePrime >= 4 && huePrime <= 5) {
        red = intermediateValue;
        green = 0;
        blue = chroma;
    }
    if (huePrime >= 5 && huePrime <= 6) {
        red = chroma;
        green = 0;
        blue = intermediateValue;
    }
    const chromaBrightnessDelta = brightness - chroma;
    red += chromaBrightnessDelta;
    green += chromaBrightnessDelta;
    blue += chromaBrightnessDelta;
    return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255),
        alpha
    };
}
function rgbToHsb(color) {
    const { red, green, blue, alpha = 1 } = color;
    const r = red / 255;
    const g = green / 255;
    const b = blue / 255;
    const largestComponent = Math.max(r, g, b);
    const smallestComponent = Math.min(r, g, b);
    const delta = largestComponent - smallestComponent;
    const saturation = largestComponent === 0 ? 0 : delta / largestComponent;
    let huePercentage = 0;
    switch (largestComponent) {
        case r:
            huePercentage = (g - b) / delta + (g < b ? 6 : 0);
            break;
        case g:
            huePercentage = (b - r) / delta + 2;
            break;
        case b:
            huePercentage = (r - g) / delta + 4;
    }
    const hue = Math.round(huePercentage / 6 * 360);
    return {
        hue: clamp(hue, 0, 360) || 0,
        saturation: clamp(saturation, 0, 1),
        brightness: clamp(largestComponent, 0, 1),
        alpha
    };
}

// see https://github.com/oliviertassinari/react-event-listener/
class EventListener$1 extends PureComponent {
    componentDidMount() {
        this.attachListener();
    }
    componentWillUpdate() {
        this.detachListener();
    }
    componentDidUpdate() {
        this.attachListener();
    }
    componentWillUnmount() {
        this.detachListener();
    }
    render() {
        return null;
    }
    attachListener() {
        const { event, handler, capture, passive } = this.props;
        addEventListener(window, event, handler, { capture, passive });
    }
    detachListener() {
        const { event, handler, capture } = this.props;
        removeEventListener(window, event, handler, capture);
    }
}

var styles$25 = {
  "ColorPicker": "p_hz",
  "MainColor": "p_ta",
  "Dragger": "p_uy",
  "ColorLayer": "p_cw",
  "HuePicker": "p_qx",
  "AlphaPicker": "p_my",
  "Slidable": "p_kw",
  "skeletonShimmerAnimation": "p_kj",
};

class Slidable extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false
        };
        this.node = null;
        this.draggerNode = null;
    }
    componentDidMount() {
        const { onDraggerHeight } = this.props;
        if (onDraggerHeight == null) {
            return;
        }
        const { draggerNode } = this;
        if (draggerNode == null) {
            return;
        }
        onDraggerHeight(draggerNode.clientWidth);
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                onDraggerHeight(draggerNode.clientWidth);
            }, 0);
        }
    }
    render() {
        const { dragging } = this.state;
        const { draggerX = 0, draggerY = 0 } = this.props;
        const draggerPositioning = {
            transform: `translate3d(${draggerX}px, ${draggerY}px, 0)`
        };
        const moveListener = dragging ? createElement(EventListener$1, { event: 'mousemove', handler: this.handleMove }) : null;
        const touchMoveListener = dragging ? createElement(EventListener$1, { event: 'touchmove', handler: this.handleMove }) : null;
        const endDragListener = dragging ? createElement(EventListener$1, { event: 'mouseup', handler: this.handleDragEnd }) : null;
        const touchEndListener = dragging ? createElement(EventListener$1, { event: 'touchend', handler: this.handleDragEnd }) : null;
        const touchCancelListener = dragging ? createElement(EventListener$1, { event: 'touchcancel', handler: this.handleDragEnd }) : null;
        return createElement(
            'div',
            { ref: this.setNode, className: styles$25.Slidable, onMouseDown: this.startDrag, onTouchStart: this.startDrag },
            endDragListener,
            moveListener,
            touchMoveListener,
            touchEndListener,
            touchCancelListener,
            createElement('div', { style: draggerPositioning, className: styles$25.Dragger, ref: this.setDraggerNode })
        );
    }
    setDraggerNode(node) {
        this.draggerNode = node;
    }
    setNode(node) {
        this.node = node;
    }
    startDrag(event) {
        if (event.type === 'mousedown') {
            const mouseEvent = event;
            this.handleDraggerMove(mouseEvent.clientX, mouseEvent.clientY);
        }
        this.setState({ dragging: true });
    }
    handleDragEnd() {
        this.setState({ dragging: false });
    }
    handleMove(event) {
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        if (event.type === 'mousemove') {
            const mouseEvent = event;
            this.handleDraggerMove(mouseEvent.clientX, mouseEvent.clientY);
            return;
        }
        const touchEvent = event;
        this.handleDraggerMove(touchEvent.touches[0].clientX, touchEvent.touches[0].clientY);
    }
    handleDraggerMove(x, y) {
        if (this.node == null) {
            return;
        }
        const { onChange } = this.props;
        const rect = this.node.getBoundingClientRect();
        const offsetX = x - rect.left;
        const offsetY = y - rect.top;
        onChange({ x: offsetX, y: offsetY });
    }
}
__decorate([autobind], Slidable.prototype, "setDraggerNode", null);
__decorate([autobind], Slidable.prototype, "setNode", null);
__decorate([autobind], Slidable.prototype, "startDrag", null);
__decorate([autobind], Slidable.prototype, "handleDragEnd", null);
__decorate([autobind], Slidable.prototype, "handleMove", null);
__decorate([autobind], Slidable.prototype, "handleDraggerMove", null);

const VERTICAL_PADDING = 13;
class HuePicker extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false,
            sliderHeight: 0,
            draggerHeight: 0
        };
    }
    render() {
        const { hue } = this.props;
        const { sliderHeight, draggerHeight } = this.state;
        const offset = offsetForHue(hue, sliderHeight, draggerHeight);
        const draggerY = clamp(offset, 0, sliderHeight);
        return createElement(
            'div',
            { className: styles$25.HuePicker, ref: this.setSliderHeight },
            createElement(Slidable, { draggerY: draggerY, draggerX: 0, onChange: this.handleChange, onDraggerHeight: this.setDraggerHeight })
        );
    }
    setSliderHeight(node) {
        if (node == null) {
            return;
        }
        this.setState({ sliderHeight: node.clientHeight });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ sliderHeight: node.clientHeight });
            }, 0);
        }
    }
    setDraggerHeight(height) {
        this.setState({
            draggerHeight: height
        });
    }
    handleChange({ y }) {
        const { onChange } = this.props;
        const { sliderHeight } = this.state;
        const offsetY = clamp(y, 0, sliderHeight);
        const hue = hueForOffset(offsetY, sliderHeight);
        onChange(hue);
    }
}
__decorate([autobind], HuePicker.prototype, "setSliderHeight", null);
__decorate([autobind], HuePicker.prototype, "setDraggerHeight", null);
__decorate([autobind], HuePicker.prototype, "handleChange", null);
function offsetForHue(hue, sliderHeight, draggerHeight) {
    const slidableArea = sliderHeight - (draggerHeight + VERTICAL_PADDING);
    return clamp(hue / 360 * slidableArea + VERTICAL_PADDING, 0, sliderHeight - draggerHeight);
}
function hueForOffset(offset, sliderHeight) {
    const selectionHeight = offset - VERTICAL_PADDING;
    const slidableArea = sliderHeight - VERTICAL_PADDING * 2;
    return clamp(selectionHeight / slidableArea * 360, 0, 360);
}

const VERTICAL_PADDING$1 = 13;
class AlphaPicker extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            dragging: false,
            sliderHeight: 0,
            draggerHeight: 0
        };
    }
    render() {
        const { color, alpha } = this.props;
        const { sliderHeight, draggerHeight } = this.state;
        const offset = offsetForAlpha(alpha, sliderHeight, draggerHeight);
        const draggerY = clamp(offset, 0, sliderHeight);
        const background = alphaGradientForColor(color);
        return createElement(
            'div',
            { className: styles$25.AlphaPicker, ref: this.setSliderHeight },
            createElement('div', { className: styles$25.ColorLayer, style: { background } }),
            createElement(Slidable, { draggerY: draggerY, draggerX: 0, onChange: this.handleChange, onDraggerHeight: this.setDraggerHeight })
        );
    }
    setSliderHeight(node) {
        if (node == null) {
            return;
        }
        this.setState({ sliderHeight: node.clientHeight });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ sliderHeight: node.clientHeight });
            }, 0);
        }
    }
    setDraggerHeight(height) {
        this.setState({
            draggerHeight: height
        });
    }
    handleChange({ y }) {
        const { onChange } = this.props;
        const { sliderHeight } = this.state;
        const offsetY = clamp(y, 0, sliderHeight);
        const alpha = alphaForOffset(offsetY, sliderHeight);
        onChange(alpha);
    }
}
__decorate([autobind], AlphaPicker.prototype, "setSliderHeight", null);
__decorate([autobind], AlphaPicker.prototype, "setDraggerHeight", null);
__decorate([autobind], AlphaPicker.prototype, "handleChange", null);
function alphaForOffset(offset, sliderHeight) {
    const selectionHeight = offset - VERTICAL_PADDING$1;
    const slidableArea = sliderHeight - VERTICAL_PADDING$1 * 2;
    return clamp(1 - selectionHeight / slidableArea, 0, 1);
}
function offsetForAlpha(alpha, sliderHeight, draggerHeight) {
    const slidableArea = sliderHeight - (draggerHeight + VERTICAL_PADDING$1);
    return clamp((1 - alpha) * slidableArea + VERTICAL_PADDING$1, 0, sliderHeight - draggerHeight);
}
function alphaGradientForColor(color) {
    const { red, green, blue } = hsbToRgb(color);
    const rgb = `${red}, ${green}, ${blue}`;
    return `linear-gradient(to top, rgba(${rgb}, 0) 18px, rgba(${rgb}, 1) calc(100% - 18px))`;
}

class ColorPicker$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            pickerSize: 0
        };
        this.colorNode = null;
    }
    componentDidMount() {
        const { colorNode } = this;
        if (colorNode == null) {
            return;
        }
        // eslint-disable-next-line react/no-did-mount-set-state
        this.setState({ pickerSize: colorNode.clientWidth });
        if (process.env.NODE_ENV === 'development') {
            setTimeout(() => {
                this.setState({ pickerSize: colorNode.clientWidth });
            }, 0);
        }
    }
    render() {
        const { color, allowAlpha } = this.props;
        const { hue, saturation, brightness, alpha: providedAlpha } = color;
        const { pickerSize } = this.state;
        const alpha = providedAlpha != null && allowAlpha ? providedAlpha : 1;
        const { red, green, blue } = hsbToRgb({ hue, saturation: 1, brightness: 1 });
        const colorString = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
        const draggerX = clamp(saturation * pickerSize, 0, pickerSize);
        const draggerY = clamp(pickerSize - brightness * pickerSize, 0, pickerSize);
        const alphaSliderMarkup = allowAlpha ? createElement(AlphaPicker, { alpha: alpha, color: color, onChange: this.handleAlphaChange }) : null;
        return createElement(
            'div',
            { className: styles$25.ColorPicker },
            createElement(
                'div',
                { ref: this.setColorNode, className: styles$25.MainColor },
                createElement('div', { className: styles$25.ColorLayer, style: { backgroundColor: colorString } }),
                createElement(Slidable, { onChange: this.handleDraggerMove, draggerX: draggerX, draggerY: draggerY })
            ),
            createElement(HuePicker, { hue: hue, onChange: this.handleHueChange }),
            alphaSliderMarkup
        );
    }
    setColorNode(node) {
        this.colorNode = node;
    }
    handleHueChange(hue) {
        const { color: { brightness, saturation, alpha = 1 }, onChange } = this.props;
        onChange({ hue, brightness, saturation, alpha });
    }
    handleAlphaChange(alpha) {
        const { color: { hue, brightness, saturation }, onChange } = this.props;
        onChange({ hue, brightness, saturation, alpha });
    }
    handleDraggerMove({ x, y }) {
        const { pickerSize } = this.state;
        const { color: { hue, alpha = 1 }, onChange } = this.props;
        const saturation = clamp(x / pickerSize, 0, 1);
        const brightness = clamp(1 - y / pickerSize, 0, 1);
        onChange({ hue, saturation, brightness, alpha });
    }
}
__decorate([autobind], ColorPicker$1.prototype, "setColorNode", null);
__decorate([autobind], ColorPicker$1.prototype, "handleHueChange", null);
__decorate([autobind], ColorPicker$1.prototype, "handleAlphaChange", null);
__decorate([autobind], ColorPicker$1.prototype, "handleDraggerMove", null);

var styles$26 = {
  "Connected": "p_sj",
  "Item": "p_gt",
  "Item-primary": "p_wm",
  "Item-connection": "p_s1",
  "Item-focused": "p_p7",
  "skeletonShimmerAnimation": "p_x6",
};

var Position;
(function (Position) {
    Position[Position["Left"] = 0] = "Left";
    Position[Position["Primary"] = 1] = "Primary";
    Position[Position["Right"] = 2] = "Right";
})(Position || (Position = {}));
class Item$3 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = { focused: false };
    }
    render() {
        const { focused } = this.state;
        const { children, position } = this.props;
        const className = classNames(styles$26.Item, focused && styles$26['Item-focused'], position === Position.Primary ? styles$26['Item-primary'] : styles$26['Item-connection']);
        return createElement(
            'div',
            { onBlur: this.handleBlur, onFocus: this.handleFocus, className: className },
            children
        );
    }
    handleBlur() {
        this.setState({ focused: false });
    }
    handleFocus() {
        this.setState({ focused: true });
    }
}
__decorate([autobind], Item$3.prototype, "handleBlur", null);
__decorate([autobind], Item$3.prototype, "handleFocus", null);

function Connected$1({ children, left, right }) {
    if (left == null && right == null) {
        return Children.only(children);
    }
    const leftConnectionMarkup = left ? createElement(
        Item$3,
        { position: Position.Left },
        left
    ) : null;
    const rightConnectionMarkup = right ? createElement(
        Item$3,
        { position: Position.Right },
        right
    ) : null;
    return createElement(
        'div',
        { className: styles$26.Connected },
        leftConnectionMarkup,
        createElement(
            Item$3,
            { position: Position.Primary },
            children
        ),
        rightConnectionMarkup
    );
}

var styles$27 = {
  "DatePicker": "p_nw",
  "MonthContainer": "p_ba",
  "Month": "p_td",
  "Month-current": "p_ww",
  "Week": "p_pi",
  "WeekHeadings": "p_fs",
  "Day": "p_bu",
  "EmptyDay": "p_zm",
  "Day-today": "p_ga",
  "Day-inRange": "p_mt",
  "Day-selected": "p_ah",
  "Day-disabled": "p_o2",
  "Weekday": "p_y2",
  "Weekday-current": "p_d6",
  "Header": "p_w7",
  "Title": "p_v5",
  "skeletonShimmerAnimation": "p_x5",
};

class Day extends PureComponent {
    constructor() {
        super(...arguments);
        this.dayNode = null;
    }
    componentDidUpdate() {
        if (this.props.focused && this.dayNode) {
            this.dayNode.focus();
        }
    }
    render() {
        const { day, focused, onClick, onHover = noop, onFocus = noop, selected, inRange, inHoveringRange, disabled } = this.props;
        const handleHover = onHover.bind(null, day);
        if (!day) {
            return createElement('div', { className: styles$27.EmptyDay, onMouseOver: handleHover });
        }
        const handleClick = onClick && !disabled ? onClick.bind(null, day) : noop;
        const today = isSameDay(new Date(), day);
        const className = classNames(styles$27.Day, selected && styles$27['Day-selected'], disabled && styles$27['Day-disabled'], today && styles$27['Day-today'], (inRange || inHoveringRange) && !disabled && styles$27['Day-inRange']);
        const date = day.getDate();
        const tabIndex = (focused || selected || today || date === 1) && !disabled ? 0 : -1;
        const ariaLabel = [`${today ? 'Today ' : ''}`, `${Months[day.getMonth()]} `, `${date} `, `${day.getFullYear()}`].join('');
        return createElement(
            'button',
            {
                // eslint-disable-next-line react/jsx-no-bind
                onFocus: onFocus.bind(null, day), ref: this.setNode, tabIndex: tabIndex, className: className, onMouseOver: handleHover, onClick: handleClick, 'aria-label': ariaLabel, 'aria-selected': selected, 'aria-disabled': disabled, role: 'gridcell' },
            date
        );
    }
    setNode(node) {
        this.dayNode = node;
    }
}
__decorate([autobind], Day.prototype, "setNode", null);

function Weekday({ label, title, current }) {
    const className = classNames(styles$27.Weekday, current && styles$27['Weekday-current']);
    return createElement(
        'div',
        { 'aria-label': Weekdays[label], className: className },
        title
    );
}

const WEEKDAYS = [Weekdays.Sunday, Weekdays.Monday, Weekdays.Tuesday, Weekdays.Wednesday, Weekdays.Thursday, Weekdays.Friday, Weekdays.Saturday];
function Month({ focusedDate, selected, hoverDate, disableDatesBefore, disableDatesAfter, allowRange, onChange = noop, onHover = noop, onFocus = noop, month, year }) {
    const isInHoveringRange = allowRange ? hoveringDateIsInRange : () => false;
    const current = new Date().getMonth() === month;
    const className = classNames(styles$27.Title, current && styles$27['Month-current']);
    const weeks = getWeeksForMonth(month, year);
    const weekdays = WEEKDAYS.map(weekday => createElement(Weekday, { key: weekday, title: abbreviationForWeekday(weekday), current: current && new Date().getDay() === weekday, label: weekday }));
    function handleDateClick(selectedDate) {
        onChange(getNewRange(selected, selectedDate));
    }
    function renderWeek(day, dayIndex) {
        if (day == null) {
            const lastDayOfMonth = new Date(year, month + 1, 0);
            return (
                // eslint-disable-next-line react/jsx-no-bind
                createElement(Day, { key: dayIndex, onHover: onHover.bind(null, lastDayOfMonth) })
            );
        }
        const disabled = disableDatesBefore && isDateBefore(day, disableDatesBefore) || disableDatesAfter && isDateAfter(day, disableDatesAfter);
        return createElement(Day, { focused: focusedDate != null && isSameDay(day, focusedDate), day: day, key: dayIndex, onFocus: onFocus, onClick: handleDateClick, onHover: onHover, selected: selected != null && dateIsSelected(day, selected), inRange: selected != null && dateIsInRange(day, selected), disabled: disabled, inHoveringRange: selected != null && hoverDate != null && isInHoveringRange(day, selected, hoverDate) });
    }
    const weeksMarkup = weeks.map((week, index) => createElement(
        'div',
        { role: 'row', className: styles$27.Week, key: index },
        week.map(renderWeek)
    ));
    return createElement(
        'div',
        { role: 'grid', className: styles$27.Month },
        createElement(
            'div',
            { className: className },
            Months[month],
            ' ',
            year
        ),
        createElement(
            'div',
            { role: 'rowheader', className: styles$27.WeekHeadings },
            weekdays
        ),
        weeksMarkup
    );
}
function hoveringDateIsInRange(day, range, hoverEndDate) {
    if (day == null) {
        return false;
    }
    const { start, end } = range;
    return Boolean(start === end && day > start && day <= hoverEndDate);
}

class DatePicker$1 extends PureComponent {
    constructor(props) {
        super(props);
        const { selected } = props;
        const range = selected instanceof Date ? { start: selected, end: selected } : selected;
        this.state = {
            hoverDate: range && range.end
        };
    }
    render() {
        const { month, year, multiMonth, disableDatesBefore, disableDatesAfter, selected } = this.props;
        const { hoverDate, focusDate } = this.state;
        const allowRange = selected != null && !(selected instanceof Date);
        const range = selected != null && selected instanceof Date ? { start: selected, end: selected } : selected;
        const showNextYear = getNextDisplayYear(month, year);
        const showNextMonth = getNextDisplayMonth(month);
        const showNextToNextYear = getNextDisplayYear(showNextMonth, showNextYear);
        const showNextToNextMonth = getNextDisplayMonth(showNextMonth);
        const showPreviousYear = getPreviousDisplayYear(month, year);
        const showPreviousMonth = getPreviousDisplayMonth(month);
        const previousMonthName = Months[showPreviousMonth];
        const nextMonth = multiMonth ? Months[showNextToNextMonth] : Months[showNextMonth];
        const nextYear = multiMonth ? showNextToNextYear : showNextYear;
        const secondDatePicker = multiMonth ? createElement(Month, { onFocus: this.handleFocus, focusedDate: focusDate, month: showNextMonth, year: showNextYear, selected: range, hoverDate: hoverDate, onChange: this.handleDateSelection, onHover: this.handleHover, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter, allowRange: allowRange }) : null;
        return createElement(
            'div',
            { className: styles$27.DatePicker, onKeyDown: handleKeyDown, onKeyUp: this.handleKeyUp },
            createElement(
                'div',
                { className: styles$27.Header },
                createElement(Button$1, { plain: true, icon: 'arrowLeft', accessibilityLabel: `Show previous month, ${previousMonthName} ${showPreviousYear}`
                    // eslint-disable-next-line react/jsx-no-bind
                    , onClick: this.handleMonthChangeClick.bind(null, showPreviousMonth, showPreviousYear) }),
                createElement(Button$1, { plain: true, icon: 'arrowRight', accessibilityLabel: `Show next month, ${nextMonth} ${nextYear}`
                    // eslint-disable-next-line react/jsx-no-bind
                    , onClick: this.handleMonthChangeClick.bind(null, showNextMonth, showNextYear) })
            ),
            createElement(
                'div',
                { className: styles$27.MonthContainer },
                createElement(Month, { onFocus: this.handleFocus, focusedDate: focusDate, month: month, year: year, selected: range, hoverDate: hoverDate, onChange: this.handleDateSelection, onHover: this.handleHover, disableDatesBefore: disableDatesBefore, disableDatesAfter: disableDatesAfter, allowRange: allowRange }),
                secondDatePicker
            )
        );
    }
    handleFocus(date) {
        this.setState({
            focusDate: date
        });
    }
    handleKeyUp(event) {
        const { key } = event;
        const { selected, disableDatesBefore, disableDatesAfter } = this.props;
        const { focusDate } = this.state;
        const range = selected instanceof Date ? { start: selected, end: selected } : selected;
        const focusedDate = focusDate || range && range.start;
        if (focusedDate == null) {
            return;
        }
        if (key === 'ArrowUp') {
            const previousWeek = new Date(focusedDate);
            previousWeek.setDate(focusedDate.getDate() - 7);
            if (!(disableDatesBefore && isDateBefore(previousWeek, disableDatesBefore))) {
                this.setFocusDateAndHandleMonthChange(previousWeek);
            }
        }
        if (key === 'ArrowDown') {
            const nextWeek = new Date(focusedDate);
            nextWeek.setDate(focusedDate.getDate() + 7);
            if (!(disableDatesAfter && isDateAfter(nextWeek, disableDatesAfter))) {
                this.setFocusDateAndHandleMonthChange(nextWeek);
            }
        }
        if (key === 'ArrowRight') {
            const tomorrow = new Date(focusedDate);
            tomorrow.setDate(focusedDate.getDate() + 1);
            if (!(disableDatesAfter && isDateAfter(tomorrow, disableDatesAfter))) {
                this.setFocusDateAndHandleMonthChange(tomorrow);
            }
        }
        if (key === 'ArrowLeft') {
            const yesterday = new Date(focusedDate);
            yesterday.setDate(focusedDate.getDate() - 1);
            if (!(disableDatesBefore && isDateBefore(yesterday, disableDatesBefore))) {
                this.setFocusDateAndHandleMonthChange(yesterday);
            }
        }
    }
    setFocusDateAndHandleMonthChange(date) {
        const { onMonthChange } = this.props;
        if (onMonthChange) {
            onMonthChange(date.getMonth(), date.getFullYear());
        }
        this.setState({
            hoverDate: date,
            focusDate: date
        });
    }
    handleDateSelection(selected) {
        const { end: endDate } = selected;
        const { onChange = noop } = this.props;
        this.setState({
            hoverDate: endDate,
            focusDate: new Date(endDate)
        });
        onChange(selected);
    }
    handleMonthChangeClick(month, year) {
        const { onMonthChange } = this.props;
        if (!onMonthChange) {
            return;
        }
        this.setState({
            focusDate: undefined
        });
        onMonthChange(month, year);
    }
    handleHover(date) {
        this.setState({
            hoverDate: date
        });
    }
}
__decorate([autobind], DatePicker$1.prototype, "handleFocus", null);
__decorate([autobind], DatePicker$1.prototype, "handleKeyUp", null);
__decorate([autobind], DatePicker$1.prototype, "setFocusDateAndHandleMonthChange", null);
__decorate([autobind], DatePicker$1.prototype, "handleDateSelection", null);
__decorate([autobind], DatePicker$1.prototype, "handleMonthChangeClick", null);
__decorate([autobind], DatePicker$1.prototype, "handleHover", null);
function handleKeyDown(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}

var styles$28 = {
  "DescriptionList": "p_ad",
  "Term": "p_k1",
  "Description": "p_bp",
  "skeletonShimmerAnimation": "p_ua",
};

const getUniqueTermKey = createUniqueIDFactory(`Term`);
const getUniqueDescriptionKey = createUniqueIDFactory(`Description`);
function DescriptionList$1({ items }) {
    const terms = items.reduce((allTerms, { term, description }) => [...allTerms, createElement(
        'dt',
        { key: getUniqueTermKey(), className: styles$28.Term },
        term
    ), createElement(
        'dd',
        { key: getUniqueDescriptionKey(), className: styles$28.Description },
        description
    )], []);
    return createElement(
        'dl',
        { className: styles$28.DescriptionList },
        terms
    );
}

var styles$29 = {
  "DisplayText": "p_y7",
  "sizeSmall": "p_il",
  "sizeMedium": "p_wa",
  "sizeLarge": "p_q0",
  "sizeExtraLarge": "p_gh",
  "skeletonShimmerAnimation": "p_bd",
};

function DisplayText$1({ element: Element = 'p', children, size = 'medium' }) {
    const className = classNames(styles$29.DisplayText, size && styles$29[variationName('size', size)]);
    return createElement(
        Element,
        { className: className },
        children
    );
}

var styles$30 = {
  "EmptyState": "p_rl",
  "imageContained": "p_hc",
  "Image": "p_na",
  "Section": "p_r9",
  "ImageContainer": "p_a0",
  "DetailsContainer": "p_iu",
  "Details": "p_bf",
  "Content": "p_pa",
  "Actions": "p_js",
  "skeletonShimmerAnimation": "p_uf",
};

class EmptyState$1 extends PureComponent {
  render() {
    const { children, heading, image, largeImage, imageContained, action, secondaryAction } = this.props;
    const className = classNames(styles$30.EmptyState, imageContained && styles$30.imageContained);
    const imageMarkup = largeImage ? createElement(Image$1, { alt: '', role: 'presentation', className: styles$30.Image, source: largeImage, sourceSet: [{ source: image, descriptor: '568w' }, { source: largeImage, descriptor: '1136w' }], sizes: '(max-width: 568px) 60vw' }) : createElement(Image$1, { role: 'presentation', alt: '', className: styles$30.Image, source: image });
    const secondaryActionMarkup = secondaryAction ? buttonFrom(secondaryAction, { plain: true }) : null;
    return createElement(
      'div',
      { className: className },
      createElement(
        'div',
        { className: styles$30.Section },
        createElement(
          'div',
          { className: styles$30.DetailsContainer },
          createElement(
            'div',
            { className: styles$30.Details },
            createElement(
              TextContainer$1,
              null,
              createElement(
                DisplayText$1,
                { size: 'medium' },
                heading
              ),
              createElement(
                'div',
                { className: styles$30.Content },
                children
              )
            ),
            createElement(
              'div',
              { className: styles$30.Actions },
              createElement(
                ButtonGroup$1,
                null,
                buttonFrom(action, { primary: true, size: 'large' }),
                secondaryActionMarkup
              )
            )
          )
        ),
        createElement(
          'div',
          { className: styles$30.ImageContainer },
          imageMarkup
        )
      )
    );
  }
}

var styles$31 = {
  "FooterHelp": "p_oz",
  "Content": "p_jq",
  "Icon": "p_di",
  "Text": "p_p9",
  "skeletonShimmerAnimation": "p_rn",
};

function FooterHelp$1({ children }) {
  return createElement(
    'div',
    { className: styles$31.FooterHelp },
    createElement(
      'div',
      { className: styles$31.Content },
      createElement(
        'div',
        { className: styles$31.Icon },
        createElement(Icon$1, { source: 'help', color: 'teal', backdrop: true })
      ),
      createElement(
        'div',
        { className: styles$31.Text },
        children
      )
    )
  );
}

var styles$32 = {
  "FormLayout": "p_li",
  "condensed": "p_v2",
  "Item": "p_bm",
  "Title": "p_t9",
  "Items": "p_jf",
  "HelpText": "p_mr",
  "skeletonShimmerAnimation": "p_d9",
};

function Item$4(props) {
    return createElement(
        'div',
        { className: styles$32.Item },
        props.children
    );
}

const getUniqueID$3 = createUniqueIDFactory('FormLayoutGroup');
function Group({ children, condensed, title, helpText }) {
    const className = classNames(condensed && styles$32.condensed);
    const id = getUniqueID$3();
    let helpTextElement = null;
    let helpTextID;
    let titleElement = null;
    let titleID;
    if (helpText) {
        helpTextID = `${id}HelpText`;
        helpTextElement = createElement(
            'div',
            { id: helpTextID, className: styles$32.HelpText },
            helpText
        );
    }
    if (title) {
        titleID = `${id}Title`;
        titleElement = createElement(
            'div',
            { id: titleID, className: styles$32.Title },
            title
        );
    }
    const itemsMarkup = Children.map(children, child => wrapWithComponent(child, Item$4));
    return createElement(
        'div',
        { role: 'group', className: className, 'aria-labelledby': titleID, 'aria-describedby': helpTextID },
        titleElement,
        createElement(
            'div',
            { className: styles$32.Items },
            itemsMarkup
        ),
        helpTextElement
    );
}

class FormLayout$1 extends PureComponent {
    render() {
        const { children } = this.props;
        return createElement(
            'div',
            { className: styles$32.FormLayout },
            Children.map(children, wrapChildren)
        );
    }
}
FormLayout$1.Group = Group;
function wrapChildren(child, index) {
    if (isElementOfType(child, Group)) {
        return child;
    }
    const props = { key: index };
    return wrapWithComponent(child, Item$4, props);
}

var styles$33 = {
  "KeyboardKey": "p_ov",
  "skeletonShimmerAnimation": "p_xu",
};

function KeyboardKey$1({ children }) {
    let key = children || '';
    key = key.length > 1 ? key.toLowerCase() : key.toUpperCase();
    return createElement(
        'kbd',
        { className: styles$33.KeyboardKey },
        key
    );
}

class KeypressListener$1 extends Component {
    componentDidMount() {
        addEventListener(document, 'keyup', this.handleKeyEvent);
    }
    componentWillUnmount() {
        removeEventListener(document, 'keyup', this.handleKeyEvent);
    }
    render() {
        return null;
    }
    handleKeyEvent(event) {
        const { keyCode, handler } = this.props;
        if (event.keyCode === keyCode) {
            handler(event);
        }
    }
}
__decorate([autobind], KeypressListener$1.prototype, "handleKeyEvent", null);

var styles$34 = {
  "Label": "p_mi",
  "hidden": "p_f2",
  "Text": "p_dv",
  "skeletonShimmerAnimation": "p_zi",
};

function labelID(id) {
    return `${id}Label`;
}
function Label$1({ children, id, hidden }) {
    const className = classNames(styles$34.Label, hidden && styles$34.hidden);
    return createElement(
        'div',
        { className: className },
        createElement(
            'label',
            { id: labelID(id), htmlFor: id, className: styles$34.Text },
            children
        )
    );
}

var styles$35 = {
  "hidden": "p_gr",
  "LabelWrapper": "p_wp",
  "HelpText": "p_ar",
  "Error": "p_jt",
  "ErrorIcon": "p_dw",
  "skeletonShimmerAnimation": "p_ut",
};

function Labelled$1(_a) {
  var { id, label, error, action, helpText, children, labelHidden } = _a,
      rest = __rest(_a, ["id", "label", "error", "action", "helpText", "children", "labelHidden"]);
  const className = classNames(labelHidden && styles$35.hidden);
  const actionMarkup = action ? buttonFrom(action, { plain: true }) : null;
  const helpTextMarkup = helpText ? createElement(
    'div',
    { className: styles$35.HelpText, id: helpTextID$1(id) },
    helpText
  ) : null;
  const errorMarkup = typeof error === 'string' ? createElement(
    'div',
    { id: errorID$1(id), className: styles$35.Error },
    createElement(
      'div',
      { className: styles$35.ErrorIcon },
      createElement(Icon$1, { source: 'alert' })
    ),
    error
  ) : null;
  const labelMarkup = label ? createElement(
    'div',
    { className: styles$35.LabelWrapper },
    createElement(
      Label$1,
      Object.assign({ id: id }, rest, { hidden: false }),
      label
    ),
    actionMarkup
  ) : null;
  return createElement(
    'div',
    { className: className },
    labelMarkup,
    children,
    errorMarkup,
    helpTextMarkup
  );
}
function errorID$1(id) {
  return `${id}Error`;
}
function helpTextID$1(id) {
  return `${id}HelpText`;
}

var styles$36 = {
  "Layout": "p_g9",
  "Section": "p_fp",
  "Section-secondary": "p_sv",
  "Section-fullWidth": "p_yc",
  "AnnotatedSection": "p_qn",
  "AnnotationWrapper": "p_kr",
  "AnnotationContent": "p_xg",
  "Annotation": "p_e5",
  "skeletonShimmerAnimation": "p_kx",
};

function Section$2({ children, secondary, fullWidth }) {
    const className = classNames(styles$36.Section, secondary && styles$36['Section-secondary'], fullWidth && styles$36['Section-fullWidth']);
    return createElement(
        'div',
        { className: className },
        children
    );
}

function AnnotatedSection(props) {
  const { children, title, description } = props;
  const wrappedDescription = typeof description === 'string' ? createElement(
    'p',
    null,
    description
  ) : description;
  return createElement(
    'div',
    { className: styles$36.AnnotatedSection },
    createElement(
      'div',
      { className: styles$36.AnnotationWrapper },
      createElement(
        'div',
        { className: styles$36.Annotation },
        createElement(
          TextContainer$1,
          null,
          createElement(
            Heading$1,
            null,
            title
          ),
          wrappedDescription
        )
      ),
      createElement(
        'div',
        { className: styles$36.AnnotationContent },
        children
      )
    )
  );
}

class Layout$1 extends Component {
    render() {
        const { children, sectioned } = this.props;
        const content = sectioned ? createElement(
            Section$2,
            null,
            children
        ) : children;
        return createElement(
            'div',
            { className: styles$36.Layout },
            content
        );
    }
}
Layout$1.AnnotatedSection = AnnotatedSection;
Layout$1.Section = Section$2;

var styles$37 = {
  "Link": "p_k7",
  "skeletonShimmerAnimation": "p_h3",
};

function Link$1({ url, children, onClick, external }) {
  return url ? createElement(
    UnstyledLink$1,
    { onClick: onClick, className: styles$37.Link, url: url, external: external },
    children
  ) : createElement(
    'button',
    { onClick: onClick, className: styles$37.Link },
    children
  );
}

var styles$38 = {
  "List": "p_ub",
  "typeBullet": "p_n0",
  "Item": "p_pt",
  "typeNumber": "p_xn",
  "skeletonShimmerAnimation": "p_kz",
};

function Item$5({ children }) {
    return createElement(
        'li',
        { className: styles$38.Item },
        children
    );
}

class ContentList extends PureComponent {
    render() {
        const { children, type = 'bullet' } = this.props;
        const className = classNames(styles$38.List, type && styles$38[variationName('type', type)]);
        const ListElement = type === 'bullet' ? 'ul' : 'ol';
        return createElement(
            ListElement,
            { className: className },
            children
        );
    }
}
ContentList.Item = Item$5;

var styles$39 = {
  "Breadcrumb": "p_tx",
  "Icon": "p_j6",
  "Content": "p_sz",
  "skeletonShimmerAnimation": "p_i4",
};

class Breadcrumbs$1 extends PureComponent {
  render() {
    const { breadcrumbs } = this.props;
    const breadcrumb = breadcrumbs[breadcrumbs.length - 1];
    if (breadcrumb == null) {
      return null;
    }
    const { content, url } = breadcrumb;
    return (
      // eslint-disable-next-line jsx-a11y/no-redundant-roles
      createElement(
        'nav',
        { role: 'navigation' },
        createElement(
          UnstyledLink$1,
          { key: content, url: url, className: styles$39.Breadcrumb, onMouseUp: handleMouseUpByBlurring },
          createElement(
            'span',
            { className: styles$39.Icon },
            createElement(Icon$1, { source: 'chevronLeft' })
          ),
          createElement(
            'span',
            { className: styles$39.Content },
            content
          )
        )
      )
    );
  }
}

var styles$40 = {
  "Pagination": "p_xt",
  "plain": "p_um",
  "Button": "p_w2",
  "skeletonShimmerAnimation": "p_yw",
};

function Pagination$1({ hasNext, hasPrevious, nextURL, previousURL, onNext, onPrevious, plain, accessibilityLabel }) {
  let label;
  if (accessibilityLabel) {
    label = accessibilityLabel;
  } else {
    label = 'Pagination';
  }
  const className = classNames$1(styles$40.Pagination, plain && styles$40.plain);
  const previousButton = previousURL ? createElement(
    UnstyledLink$1,
    { className: styles$40.Button, url: previousURL, onMouseUp: handleMouseUpByBlurring, 'aria-label': 'Previous' },
    createElement(Icon$1, { source: 'arrowLeft' })
  ) : createElement(
    'button',
    { onClick: onPrevious, onMouseUp: handleMouseUpByBlurring, className: styles$40.Button, 'aria-label': 'Previous', disabled: !hasPrevious },
    createElement(Icon$1, { source: 'arrowLeft' })
  );
  const nextButton = nextURL ? createElement(
    UnstyledLink$1,
    { className: styles$40.Button, url: nextURL, onMouseUp: handleMouseUpByBlurring, 'aria-label': 'Next' },
    createElement(Icon$1, { source: 'arrowRight' })
  ) : createElement(
    'button',
    { onClick: onNext, onMouseUp: handleMouseUpByBlurring, className: styles$40.Button, 'aria-label': 'Next', disabled: !hasNext },
    createElement(Icon$1, { source: 'arrowRight' })
  );
  return createElement(
    'nav',
    { className: className, 'aria-label': label },
    previousButton,
    nextButton
  );
}

var styles$41 = {
  "Scrollable": "p_vl",
  "horizontal": "p_pk",
  "vertical": "p_h5",
  "hasTopShadow": "p_b2",
  "hasBottomShadow": "p_fy",
  "skeletonShimmerAnimation": "p_b8",
};

const MAX_SCROLL_DISTANCE = 100;
const DELTA_THRESHOLD = 0.2;
const DELTA_PERCENTAGE = 0.2;
const EVENTS_TO_LOCK = ['scroll', 'touchmove', 'wheel'];
const PREFERS_REDUCED_MOTION = prefersReducedMotion();
class Scrollable$1 extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            topShadow: false,
            bottomShadow: false,
            scrollPosition: 0
        };
    }
    static forNode(node) {
        return closest(node, scrollable.selector) || document;
    }
    componentDidMount() {
        if (this.scrollArea == null) {
            return;
        }
        addEventListener(this.scrollArea, 'scroll', () => {
            window.requestAnimationFrame(this.handleScroll);
        });
        addEventListener(window, 'resize', this.handleResize);
        window.requestAnimationFrame(() => {
            this.handleScroll();
            if (this.props.hint) {
                this.scrollHint();
            }
        });
    }
    componentWillUnmount() {
        if (this.scrollArea == null) {
            return;
        }
        removeEventListener(this.scrollArea, 'scroll', this.handleScroll);
        removeEventListener(window, 'resize', this.handleResize);
    }
    componentDidUpdate() {
        const { scrollPosition } = this.state;
        if (scrollPosition && this.scrollArea && scrollPosition > 0) {
            this.scrollArea.scrollTop = scrollPosition;
        }
    }
    render() {
        const { topShadow, bottomShadow } = this.state;
        const _a = this.props,
              { children, className, horizontal, vertical = true, shadow, hint } = _a,
              rest = __rest(_a, ["children", "className", "horizontal", "vertical", "shadow", "hint"]);
        const finalClassName = classNames(className, styles$41.Scrollable, vertical && styles$41.vertical, horizontal && styles$41.horizontal, topShadow && styles$41.hasTopShadow, bottomShadow && styles$41.hasBottomShadow);
        return createElement(
            'div',
            Object.assign({ className: finalClassName }, scrollable.props, rest, { ref: this.setScrollArea }),
            children
        );
    }
    setScrollArea(scrollArea) {
        this.scrollArea = scrollArea;
    }
    handleScroll() {
        const { scrollArea } = this;
        const { shadow } = this.props;
        if (scrollArea == null) {
            return;
        }
        const { scrollTop, clientHeight, scrollHeight } = scrollArea;
        const shouldBottomShadow = Boolean(shadow && !(scrollTop + clientHeight >= scrollHeight));
        const shouldTopShadow = Boolean(shadow && scrollTop > 0);
        this.setState({
            topShadow: shouldTopShadow,
            bottomShadow: shouldBottomShadow,
            scrollPosition: scrollTop
        });
    }
    handleResize() {
        this.handleScroll();
    }
    scrollHint() {
        const { scrollArea } = this;
        if (scrollArea == null) {
            return;
        }
        const { clientHeight, scrollHeight } = scrollArea;
        if (PREFERS_REDUCED_MOTION || this.state.scrollPosition > 0 || scrollHeight <= clientHeight) {
            return;
        }
        const scrollDistance = scrollHeight - clientHeight;
        this.toggleLock();
        this.setState({
            scrollPosition: scrollDistance > MAX_SCROLL_DISTANCE ? MAX_SCROLL_DISTANCE : scrollDistance
        }, () => {
            window.requestAnimationFrame(this.scrollStep);
        });
    }
    scrollStep() {
        this.setState(({ scrollPosition }) => {
            const delta = scrollPosition * DELTA_PERCENTAGE;
            return {
                scrollPosition: delta < DELTA_THRESHOLD ? 0 : scrollPosition - delta
            };
        }, () => {
            if (this.state.scrollPosition > 0) {
                window.requestAnimationFrame(this.scrollStep);
            } else {
                this.toggleLock(false);
            }
        });
    }
    toggleLock(shouldLock = true) {
        const { scrollArea } = this;
        if (scrollArea == null) {
            return;
        }
        EVENTS_TO_LOCK.forEach(eventName => {
            if (shouldLock) {
                addEventListener(scrollArea, eventName, prevent);
            } else {
                removeEventListener(scrollArea, eventName, prevent);
            }
        });
    }
}
__decorate([autobind], Scrollable$1.prototype, "setScrollArea", null);
__decorate([autobind], Scrollable$1.prototype, "handleScroll", null);
__decorate([autobind, debounce(50, { trailing: true })], Scrollable$1.prototype, "handleResize", null);
__decorate([autobind], Scrollable$1.prototype, "scrollHint", null);
__decorate([autobind], Scrollable$1.prototype, "scrollStep", null);
function prevent(evt) {
    evt.preventDefault();
}
function prefersReducedMotion() {
    try {
        return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    } catch (err) {
        return false;
    }
}

function calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition) {
    const activatorTop = activatorRect.top;
    const activatorBottom = activatorTop + activatorRect.height;
    const spaceAbove = activatorRect.top;
    const spaceBelow = containerRect.height - activatorRect.top - activatorRect.height;
    const desiredHeight = overlayRect.height;
    const verticalMargins = overlayMargins.activator + overlayMargins.container;
    const minimumSpaceToScroll = overlayMargins.container;
    const distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0);
    const distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height);
    const enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll;
    const enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll;
    const heightIfBelow = Math.min(spaceBelow, desiredHeight);
    const heightIfAbove = Math.min(spaceAbove, desiredHeight);
    const positionIfAbove = {
        height: heightIfAbove - verticalMargins,
        top: activatorTop + containerRect.top - heightIfAbove,
        positioning: 'above'
    };
    const positionIfBelow = {
        height: heightIfBelow - verticalMargins,
        top: activatorBottom + containerRect.top,
        positioning: 'below'
    };
    if (preferredPosition === 'above') {
        return (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow;
    }
    if (preferredPosition === 'below') {
        return (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove;
    }
    if (enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll) {
        return spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow;
    }
    return distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;
}
function calculateHorizontalPosition(activatorRect, overlayRect, containerRect) {
    const maximum = containerRect.width - overlayRect.width;
    return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));
}
function rectIsOutsideOfRect(inner, outer) {
    const { center } = inner;
    return center.y < outer.top || center.y > outer.top + outer.height;
}

var styles$42 = {
  "PositionedOverlay": "p_mj",
  "calculating": "p_zy",
  "skeletonShimmerAnimation": "p_ak",
};

class PositionedOverlay$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            measuring: true,
            activatorRect: getRectForNode(this.props.activator),
            left: 0,
            top: 0,
            height: 0,
            width: null,
            positioning: 'below',
            zIndex: null,
            outsideScrollableContainer: false
        };
    }
    componentDidMount() {
        this.scrollableContainer = Scrollable$1.forNode(this.props.activator);
        if (this.scrollableContainer) {
            this.scrollableContainer.addEventListener('scroll', this.handleMeasurement);
        }
        this.handleMeasurement();
    }
    componentWillUnmount() {
        if (this.scrollableContainer) {
            this.scrollableContainer.removeEventListener('scroll', this.handleMeasurement);
        }
    }
    componentWillReceiveProps() {
        this.handleMeasurement();
    }
    componentDidUpdate() {
        const { outsideScrollableContainer, top } = this.state;
        const { onScrollOut, active } = this.props;
        if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {
            onScrollOut();
        }
    }
    render() {
        const { left, top, zIndex, width } = this.state;
        const { render } = this.props;
        const style = {
            top,
            left,
            width,
            zIndex: zIndex == null ? undefined : zIndex
        };
        return createElement(
            'div',
            { className: styles$42.PositionedOverlay, style: style, ref: this.setOverlay },
            createElement(EventListener$1, { event: 'resize', handler: this.handleMeasurement }),
            render(this.overlayDetails())
        );
    }
    overlayDetails() {
        const { measuring, left, positioning, height, activatorRect } = this.state;
        return {
            measuring,
            left,
            desiredHeight: height,
            positioning,
            activatorRect
        };
    }
    setOverlay(node) {
        this.overlay = node;
    }
    handleMeasurement() {
        this.setState({
            left: 0,
            top: 0,
            height: 0,
            positioning: 'below',
            measuring: true
        }, () => {
            if (this.overlay == null || this.scrollableContainer == null) {
                return;
            }
            const { activator, preferredPosition = 'below', onScrollOut, fullWidth } = this.props;
            const activatorRect = getRectForNode(activator);
            const currentOverlayRect = getRectForNode(this.overlay);
            const scrollableElement = isDocument(this.scrollableContainer) ? document.body : this.scrollableContainer;
            const scrollableContainerRect = getRectForNode(scrollableElement);
            const overlayRect = fullWidth ? Object.assign({}, currentOverlayRect, { width: activatorRect.width }) : currentOverlayRect;
            // If `body` is 100% height, it still acts as though it were not constrained
            // to that size. This adjusts for that.
            if (scrollableElement === document.body) {
                scrollableContainerRect.height = document.body.scrollHeight;
            }
            const overlayMargins = this.overlay.firstElementChild ? getMarginsForNode(this.overlay.firstElementChild) : { activator: 0, container: 0, horizontal: 0 };
            const containerRect = windowRect();
            const zIndexForLayer = getZIndexForLayerFromNode(activator);
            const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
            const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition);
            const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect);
            this.setState({
                measuring: false,
                activatorRect: getRectForNode(activator),
                left: horizontalPosition,
                top: verticalPosition.top,
                height: verticalPosition.height,
                width: fullWidth ? overlayRect.width : null,
                positioning: verticalPosition.positioning,
                outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
                zIndex
            });
        });
    }
}
__decorate([autobind], PositionedOverlay$1.prototype, "overlayDetails", null);
__decorate([autobind], PositionedOverlay$1.prototype, "setOverlay", null);
__decorate([autobind], PositionedOverlay$1.prototype, "handleMeasurement", null);
function intersectionWithViewport(rect) {
    const viewport = windowRect();
    return new Rect({
        top: Math.max(rect.top, 0),
        left: Math.max(rect.left, 0),
        height: Math.min(rect.height - rect.top + viewport.top, viewport.height, viewport.height - rect.top),
        width: Math.min(rect.width - rect.left + viewport.left, viewport.width, viewport.width - rect.left)
    });
}
function getMarginsForNode(node) {
    const nodeStyles = window.getComputedStyle(node);
    return {
        activator: parseFloat(nodeStyles.marginTop || ''),
        container: parseFloat(nodeStyles.marginBottom || ''),
        horizontal: parseFloat(nodeStyles.marginLeft || '')
    };
}
function getZIndexForLayerFromNode(node) {
    const layerNode = closest(node, layer.selector) || document.body;
    const zIndex = parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
    return isNaN(zIndex) ? null : zIndex;
}
function windowRect() {
    return new Rect({
        top: window.scrollY,
        left: window.scrollX,
        height: window.innerHeight,
        width: window.innerWidth
    });
}
function isDocument(node) {
    return node === document;
}

var styles$43 = {
  "Popover": "p_l2",
  "fullWidth": "p_ab",
  "Content": "p_en",
  "measuring": "p_hy",
  "exiting": "p_er",
  "positionedAbove": "p_tn",
  "Tip": "p_rk",
  "Wrapper": "p_u1",
  "Pane": "p_am",
  "Pane-fixed": "p_x3",
  "Section": "p_cc",
  "FocusTracker": "p_dd",
  "skeletonShimmerAnimation": "p_ey",
};

function Section$3({ children }) {
    return createElement(
        'div',
        { className: styles$43.Section },
        children
    );
}

function Pane({ fixed, sectioned, children }) {
    const className = classNames(styles$43.Pane, fixed && styles$43['Pane-fixed']);
    const content = sectioned ? wrapWithComponent(children, Section$3) : children;
    return fixed ? createElement(
        'div',
        { className: className },
        content
    ) : createElement(
        Scrollable$1,
        { hint: true, shadow: true, className: className },
        content
    );
}

var CloseSource;
(function (CloseSource) {
    CloseSource[CloseSource["Click"] = 0] = "Click";
    CloseSource[CloseSource["EscapeKeypress"] = 1] = "EscapeKeypress";
    CloseSource[CloseSource["FocusOut"] = 2] = "FocusOut";
    CloseSource[CloseSource["ScrollOut"] = 3] = "ScrollOut";
})(CloseSource || (CloseSource = {}));
class PopoverOverlay extends PureComponent {
    componentDidUpdate({ active: wasActive }) {
        const { active, preventAutofocus } = this.props;
        if (!active || preventAutofocus || active === wasActive) {
            return;
        }
        if (this.contentNode == null) {
            return;
        }
        write(() => {
            if (this.contentNode == null) {
                return;
            }
            const focusableChild = findFirstFocusableNode(this.contentNode);
            (focusableChild || this.contentNode).focus();
        });
    }
    render() {
        const { active } = this.props;
        return createElement(
            Transition,
            { 'in': active, timeout: 500, mountOnEnter: true, unmountOnExit: true },
            this.renderOverlay
        );
    }
    renderOverlay(transitionStatus) {
        const { active, activator, fullWidth, preferredPosition = 'below' } = this.props;
        return createElement(PositionedOverlay$1, { fullWidth: fullWidth, active: active, activator: activator, preferredPosition: preferredPosition
            // eslint-disable-next-line react/jsx-no-bind
            , render: this.renderPopover.bind(this, transitionStatus), onScrollOut: this.handleScrollOut });
    }
    renderPopover(transitionStatus, overlayDetails) {
        const { measuring, left, desiredHeight, positioning, activatorRect } = overlayDetails;
        const { id, children, sectioned, fullWidth } = this.props;
        const className = classNames(styles$43.Popover, transitionStatus && animationVariations(transitionStatus), positioning === 'above' && styles$43.positionedAbove, fullWidth && styles$43.fullWidth, measuring && styles$43.measuring);
        this.transitionStatus = transitionStatus;
        const tipMarkup = !measuring ? createElement('div', { style: { left: activatorRect.center.x - left }, className: styles$43.Tip }) : null;
        const contentStyles = measuring ? undefined : { height: desiredHeight };
        const content = createElement(
            'div',
            { id: id, tabIndex: -1, className: styles$43.Content, style: contentStyles, ref: this.setContentNode },
            renderPopoverContent(children, { sectioned })
        );
        return createElement(
            'div',
            Object.assign({ className: className }, overlay.props),
            createElement(EventListener$1, { event: 'click', handler: this.handleClick }),
            createElement(EventListener$1, { event: 'touchstart', handler: this.handleClick }),
            createElement(KeypressListener$1, { keyCode: Keys.ESCAPE, handler: this.handleEscape }),
            tipMarkup,
            createElement('div', { className: styles$43.FocusTracker
                // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
                , tabIndex: 0, onFocus: this.handleFocusFirstItem }),
            createElement(
                'div',
                { className: styles$43.Wrapper },
                content
            ),
            createElement('div', { className: styles$43.FocusTracker
                // eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
                , tabIndex: 0, onFocus: this.handleFocusLastItem })
        );
    }
    setContentNode(node) {
        this.contentNode = node;
    }
    handleClick(event) {
        const target = event.target;
        const { contentNode, props: { activator, onClose } } = this;
        const isDescendant = contentNode != null && nodeContainsDescendant(contentNode, target);
        const isActivatorDescendant = nodeContainsDescendant(activator, target);
        if (isDescendant || isActivatorDescendant || this.transitionStatus !== 'entered') {
            return;
        }
        onClose(CloseSource.Click);
    }
    handleScrollOut() {
        this.props.onClose(CloseSource.ScrollOut);
    }
    handleEscape() {
        this.props.onClose(CloseSource.EscapeKeypress);
    }
    handleFocusFirstItem() {
        this.props.onClose(CloseSource.FocusOut);
    }
    handleFocusLastItem() {
        this.props.onClose(CloseSource.FocusOut);
    }
}
__decorate([autobind], PopoverOverlay.prototype, "renderOverlay", null);
__decorate([autobind], PopoverOverlay.prototype, "renderPopover", null);
__decorate([autobind], PopoverOverlay.prototype, "setContentNode", null);
__decorate([autobind], PopoverOverlay.prototype, "handleClick", null);
__decorate([autobind], PopoverOverlay.prototype, "handleScrollOut", null);
__decorate([autobind], PopoverOverlay.prototype, "handleEscape", null);
__decorate([autobind], PopoverOverlay.prototype, "handleFocusFirstItem", null);
__decorate([autobind], PopoverOverlay.prototype, "handleFocusLastItem", null);
function renderPopoverContent(children, props) {
    const childrenArray = Children.toArray(children);
    if (isElementOfType(childrenArray[0], Pane)) {
        return childrenArray;
    }
    return wrapWithComponent(childrenArray, Pane, props);
}
function animationVariations(status) {
    switch (status) {
        case 'exiting':
            return styles$43.exiting;
        default:
            return null;
    }
}

const getUniqueID$4 = createUniqueIDFactory('Popover');
let Popover$1 = class Popover extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            activatorFocused: false
        };
        this.id = getUniqueID$4();
    }
    componentDidMount() {
        this.setAccessibilityAttributes();
    }
    componentDidUpdate() {
        this.setAccessibilityAttributes();
    }
    renderLayer() {
        const _a = this.props,
              { children, onClose, activator, activatorWrapper } = _a,
              rest = __rest(_a, ["children", "onClose", "activator", "activatorWrapper"]);
        if (this.activatorNode == null) {
            return null;
        }
        return createElement(
            PopoverOverlay,
            Object.assign({ id: this.id, activator: this.activatorNode, onClose: this.handleClose }, rest),
            children
        );
    }
    render() {
        const { activatorWrapper: WrapperComponent = 'div' } = this.props;
        return createElement(
            WrapperComponent,
            { ref: this.setActivator },
            Children.only(this.props.activator)
        );
    }
    setAccessibilityAttributes() {
        const { id, activatorContainer } = this;
        if (activatorContainer == null) {
            return;
        }
        const firstFocusable = findFirstFocusableNode(activatorContainer);
        const focusableActivator = firstFocusable || activatorContainer;
        focusableActivator.tabIndex = focusableActivator.tabIndex || 0;
        focusableActivator.setAttribute('aria-controls', id);
        focusableActivator.setAttribute('aria-owns', id);
        focusableActivator.setAttribute('aria-haspopup', 'true');
        focusableActivator.setAttribute('aria-expanded', String(this.props.active));
    }
    handleClose(source) {
        this.props.onClose(source);
        if (this.activatorContainer == null) {
            return;
        }
        if (source === CloseSource.FocusOut || source === CloseSource.EscapeKeypress) {
            focusFirstFocusableNode(this.activatorContainer, false);
        }
    }
    setActivator(node) {
        if (node == null) {
            this.activatorNode = null;
            this.activatorContainer = null;
            return;
        }
        this.activatorNode = node.firstElementChild;
        this.activatorContainer = node;
    }
};
Popover$1.Pane = Pane;
Popover$1.Section = Section$3;
__decorate([autobind], Popover$1.prototype, "handleClose", null);
__decorate([autobind], Popover$1.prototype, "setActivator", null);
Popover$1 = __decorate([layeredComponent({ idPrefix: 'Popover' })], Popover$1);
var Popover$2 = Popover$1;

var styles$44 = {
  "Page": "p_s6",
  "fullWidth": "p_gd",
  "singleColumn": "p_us",
  "Content": "p_yy",
  "Header": "p_hb",
  "Header-hasPagination": "p_y6",
  "Header-hasBreadcrumbs": "p_e7",
  "Header-hasSecondaryActions": "p_t6",
  "Header-hasSeparator": "p_ld",
  "Header-hasRollup": "p_e1",
  "IndividualActions": "p_ac",
  "Rollup": "p_po",
  "Navigation": "p_bx",
  "Pagination": "p_dh",
  "MainContent": "p_dl",
  "TitleAndActions": "p_hn",
  "Title": "p_yq",
  "Title-hidden": "p_bz",
  "Actions": "p_iy",
  "SecondaryActions": "p_ew",
  "Action": "p_cd",
  "ActionGroup": "p_vb",
  "PrimaryAction": "p_xy",
  "ActionIcon": "p_j7",
  "disabled": "p_wr",
  "ActionContent": "p_e4",
  "Details": "p_a9",
  "withActions": "p_t8",
  "skeletonShimmerAnimation": "p_vr",
};

function Action({ icon, url, external, onAction, children, disclosure, accessibilityLabel, disabled }) {
  const iconMarkup = icon ? createElement(
    'span',
    { className: styles$44.ActionIcon },
    createElement(Icon$1, { source: icon })
  ) : null;
  const disclosureIconMarkup = disclosure ? createElement(
    'span',
    { className: styles$44.ActionIcon },
    createElement(Icon$1, { source: 'caretDown' })
  ) : null;
  const contentMarkup = iconMarkup || disclosureIconMarkup ? createElement(
    'span',
    { className: styles$44.ActionContent },
    iconMarkup,
    createElement(
      'span',
      null,
      children
    ),
    disclosureIconMarkup
  ) : children;
  if (url) {
    return createElement(
      UnstyledLink$1,
      { key: children, external: external, url: url, onMouseUp: handleMouseUpByBlurring, className: styles$44.Action, 'aria-label': accessibilityLabel },
      contentMarkup
    );
  }
  const className = classNames$1(styles$44.Action, disabled && styles$44.disabled, icon && children == null && styles$44.iconOnly);
  return createElement(
    'button',
    { key: children, className: className, onClick: onAction, onMouseUp: handleMouseUpByBlurring, 'aria-label': accessibilityLabel, type: 'button', disabled: disabled },
    contentMarkup
  );
}

class Header$1 extends PureComponent {
  constructor() {
    super(...arguments);
    this.state = {
      rollupOpen: false
    };
  }
  render() {
    const { title, breadcrumbs = [], titleHidden = false, primaryAction, pagination, separator, secondaryActions } = this.props;
    const className = classNames(styles$44.Header, titleHidden && styles$44['Title-hidden'], pagination && styles$44['Header-hasPagination'], separator && styles$44['Header-hasSeparator'], breadcrumbs && breadcrumbs.length && styles$44['Header-hasBreadcrumbs'], this.hasRollup && styles$44['Header-hasRollup'], secondaryActions && secondaryActions.length && styles$44['Header-hasSecondaryActions']);
    const breadcrumbMarkup = breadcrumbs.length > 0 ? createElement(Breadcrumbs$1, { breadcrumbs: breadcrumbs }) : null;
    const primaryActionMarkup = primaryAction ? createElement(
      'div',
      { className: styles$44.PrimaryAction },
      buttonsFrom(primaryAction, { primary: true })
    ) : null;
    const paginationMarkup = pagination ? createElement(
      'div',
      { className: styles$44.Pagination },
      createElement(Pagination$1, Object.assign({}, pagination, { plain: true }))
    ) : null;
    const nonPrimaryActionsMarkup = this.renderSecondaryActions();
    const actionsMarkup = createElement(
      'div',
      { className: styles$44.Actions },
      primaryActionMarkup,
      nonPrimaryActionsMarkup
    );
    const navigationMarkup = breadcrumbMarkup || paginationMarkup ? createElement(
      'div',
      { className: styles$44.Navigation },
      breadcrumbMarkup,
      paginationMarkup
    ) : null;
    const titleMarkup = createElement(
      'div',
      { className: styles$44.Title },
      createElement(
        DisplayText$1,
        { size: 'large', element: 'h1' },
        title
      )
    );
    return primaryActionMarkup ? createElement(
      'div',
      { className: className },
      navigationMarkup,
      createElement(
        'div',
        { className: styles$44.MainContent },
        createElement(
          'div',
          { className: styles$44.TitleAndActions },
          titleMarkup,
          actionsMarkup
        ),
        primaryActionMarkup
      )
    ) : createElement(
      'div',
      { className: className },
      navigationMarkup,
      titleMarkup,
      actionsMarkup
    );
  }
  get hasRollup() {
    const { secondaryActions = [], actionGroups = [] } = this.props;
    return secondaryActions.length + actionGroups.length > 1;
  }
  renderSecondaryActions() {
    const { openActionGroup, rollupOpen } = this.state;
    const { secondaryActions = [], actionGroups = [] } = this.props;
    if (secondaryActions.length === 0 && actionGroups.length === 0) {
      return null;
    }
    const secondaryActionMarkup = secondaryActions.length > 0 ? secondaryActionsFrom(secondaryActions) : null;
    const actionGroupsMarkup = actionGroups.length > 0 ? actionGroups.map(({ title, icon, actions, details }) => {
      const detailsClassName = classNames(styles$44.Details, actions && Array.isArray(actions) && actions.length > 0 && styles$44.withActions);
      const detailsMarkup = details ? createElement(
        'div',
        { className: detailsClassName },
        details
      ) : null;
      return createElement(
        'div',
        { className: styles$44.ActionGroup, key: `ActionGroup-${title}` },
        createElement(
          Popover$2,
          { key: title, active: title === openActionGroup
            // eslint-disable-next-line react/jsx-no-bind
            , onClose: this.handleActionGroupClose.bind(this, title), activator: createElement(
              Action,
              { disclosure: true, icon: icon
                // eslint-disable-next-line react/jsx-no-bind
                , onAction: this.handleActionGroupOpen.bind(this, title) },
              title
            ) },
          createElement(ActionList$1, { items: actions
            // eslint-disable-next-line react/jsx-no-bind
            , onActionAnyItem: this.handleActionGroupClose.bind(this, title) }),
          detailsMarkup
        )
      );
    }) : null;
    const rollupMarkup = this.hasRollup ? createElement(
      'div',
      { className: styles$44.Rollup },
      createElement(
        Popover$2,
        { active: rollupOpen, onClose: this.handleRollupToggle, activator: createElement(
            Button$1,
            { disclosure: true, onClick: this.handleRollupToggle },
            'Actions'
          ) },
        createElement(ActionList$1, { items: secondaryActions, sections: actionGroups.map(convertActionGroupToActionListSection), onActionAnyItem: this.handleRollupToggle })
      )
    ) : null;
    return createElement(
      'div',
      { className: styles$44.SecondaryActions },
      rollupMarkup,
      createElement(
        'div',
        { className: styles$44.IndividualActions },
        secondaryActionMarkup,
        actionGroupsMarkup
      )
    );
  }
  handleRollupToggle() {
    this.setState(({ rollupOpen }) => ({ rollupOpen: !rollupOpen }));
  }
  handleActionGroupClose(group) {
    this.setState(({ openActionGroup }) => openActionGroup === group ? { openActionGroup: undefined } : {});
  }
  handleActionGroupOpen(group) {
    this.setState({ openActionGroup: group });
  }
}
__decorate([autobind], Header$1.prototype, "handleRollupToggle", null);
function convertActionGroupToActionListSection({ title, actions }) {
  return { title, items: actions };
}
function secondaryActionsFrom(actions) {
  return actions.map((_a, index) => {
    var { content } = _a,
        action = __rest(_a, ["content"]);
    return createElement(
      Action,
      Object.assign({}, action, { key: `Action-${content || index}` }),
      content
    );
  });
}

const EASDK_PROPS = ['title', 'icon', 'breadcrumbs', 'secondaryActions', 'actionGroups', 'primaryAction', 'pagination'];
class Page$1 extends PureComponent {
    componentDidMount() {
        if (this.context.easdk == null) {
            return;
        }
        this.handleEASDKMessaging();
    }
    componentDidUpdate(prevProps) {
        if (this.context.easdk == null) {
            return;
        }
        const prevEASDKProps = pick(prevProps, EASDK_PROPS);
        const currentEASDKProps = pick(this.props, EASDK_PROPS);
        if (!isEqual(prevEASDKProps, currentEASDKProps)) {
            this.handleEASDKMessaging();
        }
    }
    render() {
        const _a = this.props,
              { children, fullWidth, singleColumn } = _a,
              rest = __rest(_a, ["children", "fullWidth", "singleColumn"]);
        const className = classNames(styles$44.Page, fullWidth && styles$44.fullWidth, singleColumn && styles$44.singleColumn);
        const headerMarkup = this.context.easdk || !this.hasHeaderContent() ? null : createElement(Header$1, rest);
        return createElement(
            'div',
            { className: className },
            headerMarkup,
            createElement(
                'div',
                { className: styles$44.Content },
                children
            )
        );
    }
    handleEASDKMessaging() {
        const { easdk } = this.context;
        if (easdk) {
            easdk.Bar.update(this.props);
        }
    }
    hasHeaderContent() {
        const { title, primaryAction, secondaryActions, breadcrumbs } = this.props;
        return title && title !== '' || primaryAction || secondaryActions && secondaryActions.length > 0 || breadcrumbs && breadcrumbs.length > 0;
    }
}
Page$1.contextTypes = { easdk: object };

var styles$45 = {
  "PageActions": "p_j9",
  "skeletonShimmerAnimation": "p_f9",
};

function PageActions$1({ primaryAction, secondaryActions }) {
  const primaryActionMarkup = primaryAction ? buttonsFrom(primaryAction, { primary: true }) : null;
  const secondaryActionsMarkup = secondaryActions ? createElement(
    ButtonGroup$1,
    null,
    buttonsFrom(secondaryActions)
  ) : null;
  const distribution = secondaryActionsMarkup ? 'equalSpacing' : 'trailing';
  return createElement(
    'div',
    { className: styles$45.PageActions },
    createElement(
      Stack$1,
      { distribution: distribution, spacing: 'tight' },
      secondaryActionsMarkup,
      primaryActionMarkup
    )
  );
}

var styles$46 = {
  "Thumbnail": "p_oc",
  "sizeSmall": "p_qh",
  "sizeMedium": "p_dn",
  "sizeLarge": "p_ne",
  "Image": "p_xi",
  "skeletonShimmerAnimation": "p_yu",
};

function Thumbnail$1({ source, alt, size = 'medium' }) {
    const className = classNames(styles$46.Thumbnail, size && styles$46[variationName('size', size)]);
    return createElement(
        'span',
        { className: className },
        createElement(Image$1, { alt: alt, source: source, className: styles$46.Image })
    );
}

var styles$47 = {
  "ResourceList": "p_qg",
  "ItemWrapper": "p_bv",
  "Item": "p_b4",
  "Item-persistActions": "p_e8",
  "Actions": "p_h8",
  "Item-focused": "p_nz",
  "AttributeThree": "p_z0",
  "Item-link": "p_ml",
  "Item-mediaAvatar": "p_tb",
  "Item-sizeSmall": "p_n4",
  "Item-sizeMedium": "p_zc",
  "Item-sizeLarge": "p_gw",
  "Item-mediaThumbnail": "p_mn",
  "Media": "p_or",
  "Container": "p_z6",
  "Content": "p_b6",
  "Attributes": "p_gm",
  "AttributeOne": "p_o7",
  "AttributeTwo": "p_x4",
  "Badge": "p_oq",
  "Disclosure": "p_w3",
  "ExceptionList": "p_mv",
  "ExceptionItem": "p_ih",
  "ExceptionItem-statusWarning": "p_t2",
  "Title": "p_s8",
  "ExceptionItem-statusCritical": "p_d3",
  "Description": "p_uq",
  "Link": "p_j3",
  "skeletonShimmerAnimation": "p_si",
};

const getUniqueID$5 = createUniqueIDFactory('ResourceListItem');
class Item$6 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            actionsMenuVisible: false,
            focused: false
        };
        this.node = null;
        this.id = getUniqueID$5();
    }
    render() {
        const { url, media, attributeOne, attributeTwo, attributeThree, badges, exceptions, actions, persistActions = false } = this.props;
        const { actionsMenuVisible, focused } = this.state;
        const attributeTwoMarkup = attributeTwo ? createElement(
            'div',
            { className: styles$47.AttributeTwo },
            attributeTwo
        ) : null;
        const badgeMarkup = badges ? createElement(
            'div',
            { className: styles$47.Badge },
            badges.map(renderBadge)
        ) : null;
        const attributeThreeMarkup = attributeThree ? createElement(
            'div',
            { className: styles$47.AttributeThree },
            attributeThree
        ) : null;
        const exceptionsMarkup = exceptions ? createElement(
            'ul',
            { className: styles$47.ExceptionList },
            exceptions.map(renderException)
        ) : null;
        let mediaSize = null;
        let mediaType = null;
        let mediaMarkup = null;
        if (media) {
            if (isElementOfType(media, Avatar$1)) {
                mediaSize = media.props.size || 'medium';
                mediaType = 'avatar';
            }
            if (isElementOfType(media, Thumbnail$1)) {
                mediaSize = media.props.size || 'medium';
                mediaType = 'thumbnail';
            }
            mediaMarkup = createElement(
                'div',
                { className: styles$47.Media },
                media
            );
        }
        const className = classNames(styles$47.Item, url && styles$47['Item-link'], focused && styles$47['Item-focused'], persistActions && styles$47['Item-persistActions'], mediaType && styles$47[variationName('Item-media', mediaType)], mediaSize && styles$47[variationName('Item-size', mediaSize)]);
        let actionsMarkup = null;
        let disclosureMarkup = null;
        if (actions) {
            if (persistActions) {
                actionsMarkup = createElement(
                    'div',
                    { className: styles$47.Actions },
                    createElement(
                        ButtonGroup$1,
                        null,
                        buttonsFrom(actions, { size: 'slim', plain: true })
                    )
                );
                disclosureMarkup = createElement(
                    'div',
                    { className: styles$47.Disclosure },
                    createElement(
                        Popover$2,
                        { activator: createElement(Button$1, { 'aria-label': 'Actions dropdown', onClick: this.handleClick, plain: true, icon: 'horizontalDots' }), onClose: this.handleCloseRequest, active: actionsMenuVisible },
                        createElement(ActionList$1, { items: actions })
                    )
                );
            } else {
                actionsMarkup = createElement(
                    'div',
                    { className: styles$47.Actions },
                    createElement(
                        ButtonGroup$1,
                        { segmented: true },
                        buttonsFrom(actions, { size: 'slim' })
                    )
                );
            }
        }
        const containerMarkup = createElement(
            'div',
            { className: styles$47.Container, id: this.id },
            mediaMarkup,
            createElement(
                'div',
                { className: styles$47.Content },
                createElement(
                    'div',
                    { className: styles$47.Attributes },
                    createElement(
                        'p',
                        { className: styles$47.AttributeOne },
                        attributeOne
                    ),
                    attributeTwoMarkup,
                    badgeMarkup,
                    attributeThreeMarkup
                ),
                exceptionsMarkup
            ),
            actionsMarkup,
            disclosureMarkup
        );
        return url ? createElement(
            'div',
            { ref: this.setNode, className: className, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.mouseEnter, onMouseLeave: this.mouseLeave },
            createElement(UnstyledLink$1, { 'aria-describedby': this.id, className: styles$47.Link, url: url }),
            containerMarkup
        ) : createElement(
            'div',
            { ref: this.setNode, className: className, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.mouseEnter, onMouseLeave: this.mouseLeave },
            containerMarkup
        );
    }
    setNode(node) {
        this.node = node;
    }
    handleFocus() {
        this.setState({ focused: true });
    }
    handleBlur(event) {
        if (this.node == null || !this.node.contains(event.relatedTarget)) {
            this.setState({ focused: false });
        }
    }
    mouseEnter() {
        this.setState({ focused: true });
    }
    mouseLeave() {
        this.setState({ focused: false });
    }
    handleClick() {
        this.setState({ actionsMenuVisible: true });
    }
    handleCloseRequest() {
        this.setState({ actionsMenuVisible: false });
    }
}
__decorate([autobind], Item$6.prototype, "setNode", null);
__decorate([autobind], Item$6.prototype, "handleFocus", null);
__decorate([autobind], Item$6.prototype, "handleBlur", null);
__decorate([autobind], Item$6.prototype, "mouseEnter", null);
__decorate([autobind], Item$6.prototype, "mouseLeave", null);
__decorate([autobind], Item$6.prototype, "handleClick", null);
__decorate([autobind], Item$6.prototype, "handleCloseRequest", null);
function renderBadge(badge) {
    return createElement(
        Badge$1,
        { key: badge.content, status: badge.status },
        badge.content
    );
}
function renderException(exception, index) {
    const { status, title, description } = exception;
    const className = classNames(styles$47.ExceptionItem, status && styles$47[variationName('ExceptionItem-status', status)]);
    const titleMarkup = title != null ? createElement(
        'div',
        { className: styles$47.Title },
        title
    ) : null;
    const descriptionMarkup = description != null ? createElement(
        'div',
        { className: styles$47.Description },
        description
    ) : null;
    return createElement(
        'li',
        { key: index, className: className },
        titleMarkup,
        descriptionMarkup
    );
}

class ResourceList$1 extends PureComponent {
    render() {
        const { items } = this.props;
        return createElement(
            'ul',
            { className: styles$47.ResourceList },
            items.map(this.renderItem)
        );
    }
    renderItem(item, index) {
        const { renderItem, idForItem = defaultIdForItem } = this.props;
        const key = idForItem(item, index);
        return createElement(
            'li',
            { key: key, className: styles$47.ItemWrapper },
            renderItem(item, index)
        );
    }
}
ResourceList$1.Item = Item$6;
__decorate([autobind], ResourceList$1.prototype, "renderItem", null);
function defaultIdForItem(item, index) {
    return item.hasOwnProperty('id') ? item.id : index;
}

var styles$48 = {
  "Select": "p_tr",
  "disabled": "p_i0",
  "Backdrop": "p_l5",
  "Icon": "p_i7",
  "error": "p_j5",
  "Input": "p_o0",
  "placeholder": "p_p2",
  "skeletonShimmerAnimation": "p_mo",
};

const PLACEHOLDER_VALUE = '__placeholder__';
const getUniqueID$6 = createUniqueIDFactory('Select');
function Select$1({ id = getUniqueID$6(), name, groups, options, labelHidden, labelAction, helpText, label, error, value, placeholder, disabled, onChange, onFocus, onBlur }) {
    let optionsMarkup;
    if (options != null) {
        optionsMarkup = options.map(renderOption);
    } else if (groups != null) {
        optionsMarkup = groups.map(renderGroup);
    }
    const isPlaceholder = value == null && placeholder != null;
    const className = classNames(styles$48.Select, error && styles$48.error, disabled && styles$48.disabled, isPlaceholder && styles$48.placeholder);
    const handleChange = onChange ? event => onChange(event.currentTarget.value, id) : undefined;
    const describedBy = [];
    if (helpText) {
        describedBy.push(helpTextID$1(id));
    }
    if (error && typeof error === 'string') {
        describedBy.push(errorID$1(id));
    }
    const placeholderOption = isPlaceholder ? createElement('option', { label: placeholder, value: PLACEHOLDER_VALUE, disabled: true, hidden: true }) : null;
    // When we have no onChange, React will complain about providing a `value`
    // (and vice versa for `defaultValue`)
    const defaultValue = onChange ? undefined : value || PLACEHOLDER_VALUE;
    const finalValue = onChange ? value || PLACEHOLDER_VALUE : undefined;
    return createElement(
        Labelled$1,
        { id: id, label: label, error: error, action: labelAction, labelHidden: labelHidden, helpText: helpText },
        createElement(
            'div',
            { className: className },
            createElement(
                'select',
                { id: id, name: name, defaultValue: defaultValue, value: finalValue, className: styles$48.Input, disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: handleChange, 'aria-invalid': Boolean(error), 'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined },
                placeholderOption,
                optionsMarkup
            ),
            createElement(
                'div',
                { className: styles$48.Icon },
                createElement(Icon$1, { source: 'arrowUpDown' })
            ),
            createElement('div', { className: styles$48.Backdrop })
        )
    );
}
function renderOption(option) {
    if (typeof option === 'string') {
        return createElement(
            'option',
            { key: option, value: option },
            option
        );
    } else {
        return createElement(
            'option',
            { key: option.value, value: option.value, disabled: option.disabled },
            option.label
        );
    }
}
function renderGroup(groupOrOption) {
    if (groupOrOption.hasOwnProperty('title')) {
        const { title, options } = groupOrOption;
        return createElement(
            'optgroup',
            { label: title, key: title },
            options.map(renderOption)
        );
    }
    return renderOption(groupOrOption);
}

function SettingToggle$1({ enabled, action, children }) {
    const actionMarkup = action ? buttonFrom(action, { primary: !enabled }) : null;
    return createElement(
        Card$1,
        { sectioned: true },
        createElement(
            SettingAction$1,
            { action: actionMarkup },
            children
        )
    );
}

var styles$49 = {
  "Tabs": "p_pn",
  "fitted": "p_ms",
  "TabContainer": "p_hk",
  "Tab": "p_dq",
  "Title": "p_n3",
  "fillSpace": "p_e0",
  "Tab-selected": "p_rb",
  "Panel": "p_ik",
  "List": "p_ui",
  "Item": "p_lg",
  "DisclosureTab": "p_nl",
  "DisclosureTab-visible": "p_q2",
  "DisclosureActivator": "p_tj",
  "TabMeasurer": "p_pw",
  "skeletonShimmerAnimation": "p_qm",
};

class Item$7 extends PureComponent {
    constructor() {
        super(...arguments);
        this.focusedNode = null;
    }
    componentDidMount() {
        const { focusedNode } = this;
        const { focused } = this.props;
        if (focusedNode && focused) {
            focusedNode.focus();
        }
    }
    componentDidUpdate() {
        const { focusedNode } = this;
        const { focused } = this.props;
        if (focusedNode && focused) {
            focusedNode.focus();
        }
    }
    render() {
        const { id, children, panelID, onClick = noop, accessibilityLabel } = this.props;
        const className = classNames(styles$49.Item);
        return createElement(
            'li',
            { role: 'presentation' },
            createElement(
                'button',
                { id: id, ref: this.setFocusedNode, onClick: onClick, className: className, 'aria-controls': panelID, 'aria-selected': false, 'aria-label': accessibilityLabel },
                children
            )
        );
    }
    setFocusedNode(node) {
        this.focusedNode = node;
    }
}
__decorate([autobind], Item$7.prototype, "setFocusedNode", null);

class List$1 extends PureComponent {
    render() {
        const { focusIndex, disclosureTabs, onClick = noop } = this.props;
        const tabs = disclosureTabs.map((tab, index) => {
            const tabContent = getTabContent(tab);
            return createElement(
                Item$7,
                { key: tab.id, id: tab.id, panelID: tab.panelID, focused: index === focusIndex, accessibilityLabel: tab.accessibilityLabel
                    // eslint-disable-next-line react/jsx-no-bind
                    , onClick: onClick.bind(null, tab.id) },
                tabContent
            );
        });
        return createElement(
            'ul',
            { className: styles$49.List, onKeyDown: handleKeyDown$2, onKeyUp: this.handleKeypress },
            tabs
        );
    }
    handleKeypress(event) {
        const { onKeyPress = noop } = this.props;
        onKeyPress(event);
    }
}
__decorate([autobind], List$1.prototype, "handleKeypress", null);
function handleKeyDown$2(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}

class Tab extends PureComponent {
    constructor() {
        super(...arguments);
        this.node = null;
    }
    // A tab can start selected when it is moved from the disclosure dropdown
    // into the main list, so we need to send focus from the tab to the panel
    // on mount and update
    componentDidMount() {
        const { id, measuring, selected, panelID, focused } = this.props;
        if (measuring) {
            return;
        }
        // Because of timing issues with the render, we may still have the old,
        // in-disclosure version of the tab that has focus. Check for this
        // as a second indicator of focus
        const itemHadFocus = focused || document.activeElement && document.activeElement.id === id;
        // If we just check for selected, the panel for the active tab will
        // be focused on page load, which we don’t want
        if (itemHadFocus && selected && panelID != null) {
            focusPanelID(panelID);
        }
    }
    componentDidUpdate(previousProps) {
        const { selected: wasSelected } = previousProps;
        const { focused, measuring, selected, panelID } = this.props;
        if (measuring) {
            return;
        }
        if (selected && !wasSelected && panelID != null) {
            focusPanelID(panelID);
        } else if (focused && this.node != null) {
            focusFirstFocusableNode(this.node);
        }
    }
    render() {
        const { id, focused, siblingTabHasFocus, children, onClick, selected, url, panelID, measuring, accessibilityLabel } = this.props;
        const handleClick = onClick && onClick.bind(null, id);
        const className = classNames(styles$49.Tab, selected && styles$49['Tab-selected']);
        let tabIndex;
        if (selected && !siblingTabHasFocus && !measuring) {
            tabIndex = 0;
        } else if (focused && !measuring) {
            tabIndex = 0;
        } else {
            tabIndex = -1;
        }
        const markup = url ? createElement(
            UnstyledLink$1,
            { id: id, url: url, role: 'tab', tabIndex: tabIndex, onClick: handleClick, className: className, 'aria-selected': selected, 'aria-controls': panelID, 'aria-label': accessibilityLabel, onMouseUp: handleMouseUpByBlurring },
            createElement(
                'span',
                { className: styles$49.Title },
                children
            )
        ) : createElement(
            'button',
            { id: id, role: 'tab', tabIndex: tabIndex, className: className, onClick: handleClick, 'aria-selected': selected, 'aria-controls': panelID, 'aria-label': accessibilityLabel, onMouseUp: handleMouseUpByBlurring },
            createElement(
                'span',
                { className: styles$49.Title },
                children
            )
        );
        return createElement(
            'li',
            { role: 'presentation', className: styles$49.TabContainer, ref: this.setNode },
            markup
        );
    }
    setNode(node) {
        this.node = node;
    }
}
__decorate([autobind], Tab.prototype, "setNode", null);
function focusPanelID(panelID) {
    const panel = document.getElementById(panelID);
    if (panel) {
        panel.focus();
    }
}

class TabMeasurer extends PureComponent {
    constructor() {
        super(...arguments);
        this.containerNode = null;
    }
    componentDidMount() {
        this.handleMeasurement();
        if (process.env.NODE_ENV === 'development') {
            // We need to defer the calculation in development so the
            // styles have time to be injected.
            setTimeout(this.handleMeasurement, 0);
        }
    }
    componentDidUpdate(prevProps) {
        if (prevProps.tabs !== this.props.tabs) {
            this.handleMeasurement();
        }
    }
    render() {
        const { selected, tabs, activator, tabToFocus, siblingTabHasFocus } = this.props;
        const tabsMarkup = tabs.map((tab, index) => {
            const tabContent = getTabContent(tab);
            return createElement(
                Tab,
                { measuring: true, key: `${index}${tab.id}Hidden`, id: `${tab.id}Measurer`, siblingTabHasFocus: siblingTabHasFocus, focused: index === tabToFocus, selected: index === selected, onClick: noop, url: tab.url },
                tabContent
            );
        });
        const classname = classNames(styles$49.Tabs, styles$49.TabMeasurer);
        return createElement(
            'div',
            { className: classname, ref: this.setContainerNode },
            createElement(EventListener$1, { event: 'resize', handler: this.handleMeasurement }),
            tabsMarkup,
            activator
        );
    }
    setContainerNode(node) {
        this.containerNode = node;
    }
    handleMeasurement() {
        if (this.containerNode == null) {
            return;
        }
        const { handleMeasurement } = this.props;
        const containerWidth = this.containerNode.offsetWidth;
        const hiddenTabNodes = findDOMNode(this).children;
        const hiddenTabNodesArray = [].slice.call(hiddenTabNodes);
        const hiddenTabWidths = hiddenTabNodesArray.map(node => {
            return node.getBoundingClientRect().width;
        });
        const disclosureWidth = hiddenTabWidths.pop();
        handleMeasurement({
            containerWidth,
            disclosureWidth,
            hiddenTabWidths
        });
    }
}
__decorate([autobind], TabMeasurer.prototype, "setContainerNode", null);
__decorate([autobind], TabMeasurer.prototype, "handleMeasurement", null);

function Panel({ id, tabID, children }) {
  return createElement(
    'div',
    { className: styles$49.Panel, id: id, role: 'tabpanel', 'aria-labelledby': tabID, tabIndex: -1 },
    children
  );
}

class Tabs$1 extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            disclosureWidth: 0,
            containerWidth: Infinity,
            tabWidths: [],
            visibleTabs: [],
            hiddenTabs: [],
            showDisclosure: false,
            tabToFocus: -1
        };
    }
    componentWillReceiveProps(nextProps) {
        const { selected } = this.props;
        const { disclosureWidth, tabWidths, containerWidth, tabToFocus } = this.state;
        const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(nextProps.tabs, nextProps.selected, disclosureWidth, tabWidths, containerWidth);
        this.setState({
            visibleTabs,
            hiddenTabs,
            tabToFocus: selected === nextProps.selected ? -1 : tabToFocus,
            showDisclosure: false
        });
    }
    render() {
        const { tabs, selected, fitted, children } = this.props;
        const { tabToFocus, visibleTabs, hiddenTabs, showDisclosure } = this.state;
        const disclosureTabs = hiddenTabs.map(tabIndex => tabs[tabIndex]);
        const panelMarkup = children ? createElement(
            Panel,
            { id: tabs[selected].panelID || `${tabs[selected].id}-panel`, tabID: tabs[selected].id },
            children
        ) : null;
        const tabsMarkup = visibleTabs.sort((tabA, tabB) => tabA - tabB).map(tabIndex => this.renderTabMarkup(tabs[tabIndex], tabIndex));
        const disclosureActivatorVisible = visibleTabs.length < tabs.length;
        const classname = classNames(styles$49.Tabs, fitted && styles$49.fitted, disclosureActivatorVisible && styles$49.fillSpace);
        const disclosureTabClassName = classNames(styles$49.DisclosureTab, disclosureActivatorVisible && styles$49['DisclosureTab-visible']);
        const activator = createElement(
            'button',
            { tabIndex: -1, className: styles$49.DisclosureActivator, onClick: this.handleDisclosureActivatorClick },
            createElement(Icon$1, { source: 'horizontalDots' })
        );
        return createElement(
            'div',
            null,
            createElement(
                'ul',
                { role: 'tablist', className: classname, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: handleKeyDown$1, onKeyUp: this.handleKeyPress },
                tabsMarkup,
                createElement(
                    'li',
                    { role: 'presentation', className: disclosureTabClassName },
                    createElement(
                        Popover$2,
                        { preventAutofocus: true, preferredPosition: 'below', activator: activator, active: disclosureActivatorVisible && showDisclosure, onClose: this.handleClose },
                        createElement(List$1, { focusIndex: hiddenTabs.indexOf(tabToFocus), disclosureTabs: disclosureTabs, onClick: this.handleTabClick, onKeyPress: this.handleKeyPress })
                    )
                )
            ),
            createElement(TabMeasurer, { tabToFocus: tabToFocus, activator: activator, selected: selected, tabs: tabs, siblingTabHasFocus: tabToFocus > -1, handleMeasurement: this.handleMeasurement }),
            panelMarkup
        );
    }
    handleKeyPress(event) {
        const { tabToFocus, visibleTabs, hiddenTabs } = this.state;
        const tabsArrayInOrder = visibleTabs.concat(hiddenTabs);
        const key = event.key;
        let newFocus = tabsArrayInOrder.indexOf(tabToFocus);
        if (key === 'ArrowRight' || key === 'ArrowDown') {
            newFocus += 1;
            if (newFocus === tabsArrayInOrder.length) {
                newFocus = 0;
            }
        }
        if (key === 'ArrowLeft' || key === 'ArrowUp') {
            newFocus -= 1;
            if (newFocus === -1) {
                newFocus = tabsArrayInOrder.length - 1;
            }
        }
        this.setState({
            showDisclosure: hiddenTabs.indexOf(tabsArrayInOrder[newFocus]) > -1,
            tabToFocus: tabsArrayInOrder[newFocus]
        });
    }
    renderTabMarkup(tab, index) {
        const { selected } = this.props;
        const { tabToFocus } = this.state;
        const tabContent = getTabContent(tab);
        return createElement(
            Tab,
            { key: `${index}-${tab.id}`, id: tab.id, siblingTabHasFocus: tabToFocus > -1, focused: index === tabToFocus, selected: index === selected, onClick: this.handleTabClick, panelID: tab.panelID || `${tab.id}-panel`, accessibilityLabel: tab.accessibilityLabel, url: tab.url },
            tabContent
        );
    }
    handleFocus(event) {
        const { selected, tabs } = this.props;
        // If we are explicitly focusing one of the non-selected tabs, use it
        // move the focus to it
        const target = event.target;
        if (target.classList.contains(styles$49.Tab) || target.classList.contains(styles$49.Item)) {
            let tabToFocus = -1;
            tabs.every((tab, index) => {
                if (tab.id === target.id) {
                    tabToFocus = index;
                    return false;
                }
                return true;
            });
            this.setState({ tabToFocus });
            return;
        }
        if (target.classList.contains(styles$49.DisclosureActivator)) {
            return;
        }
        // If we are coming in from somewhere other than another tab, focus the
        // selected tab, and the focus (click) is not on the disclosure activator,
        // focus the selected tab
        if (!event.relatedTarget) {
            this.setState({ tabToFocus: selected });
            return;
        }
        const relatedTarget = event.relatedTarget;
        if (!relatedTarget.classList.contains(styles$49.Tab) && !relatedTarget.classList.contains(styles$49.Item) && !relatedTarget.classList.contains(styles$49.DisclosureActivator)) {
            this.setState({ tabToFocus: selected });
        }
    }
    handleBlur(event) {
        // If we blur and the target is not another tab, forget the focus position
        if (event.relatedTarget == null) {
            this.setState({ tabToFocus: -1 });
            return;
        }
        const target = event.relatedTarget;
        // If we are going to anywhere other than another tab, lose the last focused tab
        if (!target.classList.contains(styles$49.Tab) && !target.classList.contains(styles$49.Item)) {
            this.setState({ tabToFocus: -1 });
        }
    }
    handleDisclosureActivatorClick() {
        this.setState(({ showDisclosure }) => ({ showDisclosure: !showDisclosure }));
    }
    handleClose() {
        this.setState({
            showDisclosure: false
        });
    }
    handleMeasurement(measurements) {
        const { tabs, selected } = this.props;
        const { tabToFocus } = this.state;
        const { hiddenTabWidths: tabWidths, containerWidth, disclosureWidth } = measurements;
        const { visibleTabs, hiddenTabs } = getVisibleAndHiddenTabIndices(tabs, selected, disclosureWidth, tabWidths, containerWidth);
        this.setState({
            tabToFocus: tabToFocus === -1 ? -1 : selected,
            visibleTabs,
            hiddenTabs,
            disclosureWidth,
            containerWidth,
            tabWidths
        });
    }
    handleTabClick(id) {
        const { tabs, onSelect = noop } = this.props;
        const tab = tabs.find(aTab => aTab.id === id);
        if (tab == null) {
            return;
        }
        const selectedIndex = tabs.indexOf(tab);
        onSelect(selectedIndex);
    }
}
Tabs$1.Panel = Panel;
__decorate([autobind], Tabs$1.prototype, "handleKeyPress", null);
__decorate([autobind], Tabs$1.prototype, "renderTabMarkup", null);
__decorate([autobind], Tabs$1.prototype, "handleFocus", null);
__decorate([autobind], Tabs$1.prototype, "handleBlur", null);
__decorate([autobind], Tabs$1.prototype, "handleDisclosureActivatorClick", null);
__decorate([autobind], Tabs$1.prototype, "handleClose", null);
__decorate([autobind], Tabs$1.prototype, "handleMeasurement", null);
__decorate([autobind], Tabs$1.prototype, "handleTabClick", null);
function handleKeyDown$1(event) {
    const { key } = event;
    if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
        event.preventDefault();
        event.stopPropagation();
    }
}
function getVisibleAndHiddenTabIndices(tabs, selected, disclosureWidth, tabWidths, containerWidth) {
    const sumTabWidths = tabWidths.reduce((sum, width) => sum + width, 0);
    const arrayOfTabIndices = tabs.map((_, index) => {
        return index;
    });
    const visibleTabs = [];
    const hiddenTabs = [];
    if (containerWidth > sumTabWidths) {
        visibleTabs.push(...arrayOfTabIndices);
    } else {
        visibleTabs.push(selected);
        let newTabWidth = tabWidths[selected];
        arrayOfTabIndices.forEach(index => {
            if (index !== selected) {
                if (newTabWidth + tabWidths[index] > containerWidth - disclosureWidth) {
                    hiddenTabs.push(index);
                    return;
                }
                visibleTabs.push(index);
                newTabWidth += tabWidths[index];
            }
        });
    }
    return {
        visibleTabs,
        hiddenTabs
    };
}
function getTabContent(tab) {
    if (isTabWithTitle(tab)) {
        // eslint-disable-next-line no-console
        console.warn('The `title` property on Tabs has been deprecated. Use `content` instead.');
        return tab.title;
    } else {
        return tab.content;
    }
}
function isTabWithTitle(tab) {
    return tab.hasOwnProperty('title');
}

var styles$50 = {
  "Tag": "p_jz",
  "Button": "p_pp",
  "skeletonShimmerAnimation": "p_im",
};

function Tag$1({ children, onRemove }) {
  return createElement(
    'span',
    { className: styles$50.Tag },
    createElement(
      'span',
      null,
      children
    ),
    createElement(
      'button',
      { type: 'button', 'aria-label': 'Remove', className: styles$50.Button, onClick: onRemove, onMouseUp: handleMouseUpByBlurring },
      createElement(Icon$1, { source: 'cancelSmall' })
    )
  );
}

var styles$51 = {
  "TextField": "p_dc",
  "multiline": "p_vs",
  "Input": "p_mp",
  "hasValue": "p_q4",
  "focus": "p_ql",
  "Backdrop": "p_ht",
  "error": "p_qr",
  "readOnly": "p_ez",
  "disabled": "p_mf",
  "Prefix": "p_zq",
  "Suffix": "p_og",
  "Spinner": "p_hp",
  "SpinnerIcon": "p_lc",
  "Resizer": "p_dk",
  "DummyInput": "p_qz",
  "Segment": "p_r0",
  "skeletonShimmerAnimation": "p_l6",
};

class Resizer extends PureComponent {
    constructor() {
        super(...arguments);
        this.contentNode = null;
        this.minimumLinesNode = null;
    }
    componentDidMount() {
        this.handleHeightCheck();
        if (process.env.NODE_ENV === 'development') {
            // We need to defer the calculation in development so the
            // styles have time to be injected.
            setTimeout(this.handleHeightCheck, 0);
        }
    }
    componentDidUpdate() {
        this.handleHeightCheck();
    }
    render() {
        const { contents, minimumLines } = this.props;
        const minimumLinesMarkup = minimumLines ? createElement('div', { ref: this.setMinimumLinesNode, className: styles$51.DummyInput, dangerouslySetInnerHTML: {
                __html: getContentsForMinimumLines(minimumLines)
            } }) : null;
        return createElement(
            'div',
            { 'aria-hidden': true, className: styles$51.Resizer },
            createElement(EventListener$1, { event: 'resize', handler: this.handleHeightCheck }),
            createElement('div', { ref: this.setContentNode, className: styles$51.DummyInput, dangerouslySetInnerHTML: { __html: getFinalContents(contents) } }),
            minimumLinesMarkup
        );
    }
    handleHeightCheck() {
        if (this.contentNode == null || this.minimumLinesNode == null) {
            return;
        }
        const contentHeight = this.contentNode.offsetHeight;
        const minimumHeight = this.setMinimumLinesNode ? this.minimumLinesNode.offsetHeight : 0;
        const newHeight = Math.max(contentHeight, minimumHeight);
        const { currentHeight, onHeightChange } = this.props;
        if (newHeight !== currentHeight) {
            onHeightChange(newHeight);
        }
    }
    setContentNode(node) {
        this.contentNode = node;
    }
    setMinimumLinesNode(node) {
        this.minimumLinesNode = node;
    }
}
__decorate([autobind], Resizer.prototype, "handleHeightCheck", null);
__decorate([autobind], Resizer.prototype, "setContentNode", null);
__decorate([autobind], Resizer.prototype, "setMinimumLinesNode", null);
const ENTITIES_TO_REPLACE = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '\n': '<br>'
};
const REPLACE_REGEX = /[\n&<>]/g;
function replaceEntity(entity) {
    return ENTITIES_TO_REPLACE[entity] || entity;
}
function getContentsForMinimumLines(minimumLines) {
    let content = '';
    for (let line = 0; line < minimumLines; line++) {
        content += '<br>';
    }
    return content;
}
function getFinalContents(contents) {
    return contents ? `${contents.replace(REPLACE_REGEX, replaceEntity)}<br>` : '<br>';
}

function Spinner$2({ onChange, onClick }) {
  function handleStep(step) {
    return () => onChange(step);
  }
  return createElement(
    'div',
    { className: styles$51.Spinner, onClick: onClick, 'aria-hidden': true },
    createElement(
      'div',
      { role: 'button', className: styles$51.Segment, tabIndex: -1, onClick: handleStep(1) },
      createElement(
        'div',
        { className: styles$51.SpinnerIcon },
        createElement(Icon$1, { source: 'caretUp' })
      )
    ),
    createElement(
      'div',
      { role: 'button', className: styles$51.Segment, tabIndex: -1, onClick: handleStep(-1) },
      createElement(
        'div',
        { className: styles$51.SpinnerIcon },
        createElement(Icon$1, { source: 'caretDown' })
      )
    )
  );
}

const getUniqueID$7 = createUniqueIDFactory('TextField');
class TextField$1 extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            height: null,
            focus: false,
            id: props.id || getUniqueID$7()
        };
    }
    componentDidUpdate({ focused }) {
        if (this.input && focused !== this.props.focused && this.props.focused === true) {
            this.input.focus();
        }
    }
    componentWillReceiveProps(newProps) {
        this.setState({
            id: newProps.id || this.state.id
        });
    }
    render() {
        const _a = this.props,
              { id = this.state.id, value = '', placeholder, disabled, readOnly, autoFocus, type, name, error, multiline, connectedRight, connectedLeft, label, labelAction, labelHidden, helpText, prefix, suffix, onFocus, onBlur, autoComplete, focused } = _a,
              rest = __rest(_a, ["id", "value", "placeholder", "disabled", "readOnly", "autoFocus", "type", "name", "error", "multiline", "connectedRight", "connectedLeft", "label", "labelAction", "labelHidden", "helpText", "prefix", "suffix", "onFocus", "onBlur", "autoComplete", "focused"]);
        const { height } = this.state;
        const className = classNames(styles$51.TextField, Boolean(value) && styles$51.hasValue, disabled && styles$51.disabled, readOnly && styles$51.readOnly, error && styles$51.error, multiline && styles$51.multiline, this.state.focus && styles$51.focus);
        const inputType = type === 'currency' ? 'text' : type;
        const prefixMarkup = prefix ? createElement(
            'div',
            { className: styles$51.Prefix, id: `${id}Prefix` },
            prefix
        ) : null;
        const suffixMarkup = suffix ? createElement(
            'div',
            { className: styles$51.Suffix, id: `${id}Suffix` },
            suffix
        ) : null;
        const spinnerMarkup = type === 'number' && !disabled ? createElement(Spinner$2, { onChange: this.handleNumberChange }) : null;
        const style = multiline && height ? { height } : null;
        const resizer = multiline != null ? createElement(Resizer, { contents: value || placeholder, currentHeight: height, minimumLines: typeof multiline === 'number' ? multiline : 1, onHeightChange: this.handleExpandingResize }) : null;
        const describedBy = [];
        if (error && typeof error === 'string') {
            describedBy.push(errorID$1(id));
        }
        if (helpText) {
            describedBy.push(helpTextID$1(id));
        }
        const labelledBy = [labelID(id)];
        if (prefix) {
            labelledBy.push(`${id}Prefix`);
        }
        if (suffix) {
            labelledBy.push(`${id}Suffix`);
        }
        const input = createElement(multiline ? 'textarea' : 'input', Object.assign({}, rest, { name,
            id,
            disabled,
            readOnly,
            autoFocus,
            value,
            placeholder,
            onFocus,
            onBlur,
            style, autoComplete: normalizeAutoComplete(autoComplete), className: styles$51.Input, onChange: this.handleChange, ref: this.setInput, type: inputType, 'aria-describedby': describedBy.length ? describedBy.join(' ') : undefined, 'aria-labelledby': labelledBy.join(' '), 'aria-invalid': Boolean(error) }));
        return createElement(
            Labelled$1,
            { label: label, id: id, error: error, action: labelAction, labelHidden: labelHidden, helpText: helpText },
            createElement(
                Connected$1,
                { left: connectedLeft, right: connectedRight },
                createElement(
                    'div',
                    { className: className, onFocus: this.handleFocus, onBlur: this.handleBlur, onClick: this.handleClick },
                    prefixMarkup,
                    input,
                    suffixMarkup,
                    spinnerMarkup,
                    createElement('div', { className: styles$51.Backdrop }),
                    resizer
                )
            )
        );
    }
    setInput(input) {
        this.input = input;
    }
    handleNumberChange(steps) {
        const { onChange, value, step = 1, min = -Infinity, max = Infinity } = this.props;
        if (onChange == null) {
            return;
        }
        // Returns the length of decimal places in a number
        const dpl = num => (num.toString().split('.')[1] || []).length;
        const numericValue = value ? parseFloat(value) : 0;
        if (isNaN(numericValue)) {
            return;
        }
        // Making sure the new value has the same length of decimal places as the
        // step / value has.
        const decimalPlaces = Math.max(dpl(numericValue), dpl(step));
        const newValue = Math.min(max, Math.max(numericValue + steps * step, min));
        onChange(String(newValue.toFixed(decimalPlaces)), this.state.id);
    }
    handleExpandingResize(height) {
        this.setState({ height });
    }
    handleChange(event) {
        const { onChange } = this.props;
        if (onChange == null) {
            return;
        }
        onChange(event.currentTarget.value, this.state.id);
    }
    handleFocus() {
        this.setState({ focus: true });
    }
    handleBlur() {
        this.setState({ focus: false });
    }
    handleClick() {
        this.input.focus();
    }
}
__decorate([autobind], TextField$1.prototype, "setInput", null);
__decorate([autobind], TextField$1.prototype, "handleNumberChange", null);
__decorate([autobind], TextField$1.prototype, "handleExpandingResize", null);
__decorate([autobind], TextField$1.prototype, "handleChange", null);
__decorate([autobind], TextField$1.prototype, "handleFocus", null);
__decorate([autobind], TextField$1.prototype, "handleBlur", null);
__decorate([autobind], TextField$1.prototype, "handleClick", null);
function normalizeAutoComplete(autoComplete) {
    if (autoComplete == null) {
        return autoComplete;
    }
    return autoComplete ? 'on' : 'off';
}

var styles$52 = {
  "Tooltip": "p_q1",
  "measuring": "p_co",
  "positionedAbove": "p_tk",
  "Tip": "p_tc",
  "light": "p_je",
  "Wrapper": "p_x2",
  "Content": "p_jm",
  "Label": "p_mq",
  "skeletonShimmerAnimation": "p_b0",
};

class TooltipOverlay extends PureComponent {
    render() {
        const markup = this.props.active ? this.renderOverlay() : null;
        return markup;
    }
    renderOverlay() {
        const { active, activator, preferredPosition = 'below' } = this.props;
        return createElement(PositionedOverlay$1, { active: active, activator: activator, preferredPosition: preferredPosition, render: this.renderTooltip });
    }
    renderTooltip(overlayDetails) {
        const { left, measuring, desiredHeight, positioning, activatorRect } = overlayDetails;
        const { id, children, light } = this.props;
        const tipStyle = calculateTipPosition(activatorRect.center.x, left);
        const containerClassName = classNames(styles$52.Tooltip, light && styles$52.light, measuring && styles$52.measuring, positioning === 'above' && styles$52.positionedAbove);
        const contentStyles = measuring ? undefined : { maxHeight: desiredHeight };
        const tipMarkup = !measuring ? createElement('div', { style: tipStyle, className: styles$52.Tip }) : null;
        return createElement(
            'div',
            Object.assign({ className: containerClassName }, layer.props),
            tipMarkup,
            createElement(
                'div',
                { className: styles$52.Wrapper },
                createElement(
                    'div',
                    { id: id, role: 'tooltip', className: styles$52.Content, style: contentStyles },
                    children
                )
            )
        );
    }
}
__decorate([autobind], TooltipOverlay.prototype, "renderOverlay", null);
__decorate([autobind], TooltipOverlay.prototype, "renderTooltip", null);
function calculateTipPosition(activatorRectXAxisCenter, left) {
    return { left: activatorRectXAxisCenter - left };
}

const getUniqueID$8 = createUniqueIDFactory('TooltipContent');
let Tooltip$1 = class Tooltip extends PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            active: false
        };
        this.id = getUniqueID$8();
    }
    componentDidMount() {
        this.setAccessibilityAttributes();
    }
    componentDidUpdate() {
        this.setAccessibilityAttributes();
    }
    renderLayer() {
        const { id, activatorNode } = this;
        if (activatorNode == null) {
            return null;
        }
        const { preferredPosition = 'below', active, light, content } = this.props;
        return createElement(
            TooltipOverlay,
            { id: id, preferredPosition: preferredPosition, activator: activatorNode, active: active || this.state.active, onClose: noop, light: light },
            createElement(
                'div',
                { className: styles$52.Label },
                content
            )
        );
    }
    render() {
        const { activatorWrapper: WrapperComponent = 'span' } = this.props;
        return createElement(
            WrapperComponent,
            { onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, ref: this.setActivator },
            this.props.children
        );
    }
    setActivator(node) {
        if (node == null) {
            this.activatorNode = null;
            this.activatorContainer = null;
            return;
        }
        this.activatorNode = node.firstElementChild;
        this.activatorContainer = node;
    }
    handleFocus() {
        this.setState({ active: true });
    }
    handleBlur() {
        this.setState({ active: false });
    }
    handleMouseEnter() {
        this.setState({ active: true });
    }
    handleMouseLeave() {
        this.setState({ active: false });
    }
    setAccessibilityAttributes() {
        const { activatorContainer, id } = this;
        if (activatorContainer == null) {
            return;
        }
        const firstFocusable = findFirstFocusableNode(activatorContainer);
        const accessibilityNode = firstFocusable || activatorContainer;
        accessibilityNode.tabIndex = 0;
        accessibilityNode.setAttribute('aria-describedby', id);
    }
};
__decorate([autobind], Tooltip$1.prototype, "setActivator", null);
__decorate([autobind], Tooltip$1.prototype, "handleFocus", null);
__decorate([autobind], Tooltip$1.prototype, "handleBlur", null);
__decorate([autobind], Tooltip$1.prototype, "handleMouseEnter", null);
__decorate([autobind], Tooltip$1.prototype, "handleMouseLeave", null);
Tooltip$1 = __decorate([layeredComponent({ idPrefix: 'Tooltip' })], Tooltip$1);
var Tooltip$2 = Tooltip$1;

var styles$53 = {
  "DisplayText": "p_y4",
  "skeletonShimmerAnimation": "p_dg",
  "sizeSmall": "p_to",
  "sizeMedium": "p_zg",
  "sizeLarge": "p_e9",
  "sizeExtraLarge": "p_rs",
};

function SkeletonDisplayText$1({ size = 'medium' }) {
    const className = classNames(styles$53.DisplayText, size && styles$53[variationName('size', size)]);
    return createElement('div', { className: className });
}

var styles$54 = {
  "SkeletonBodyTextContainer": "p_jy",
  "skeletonShimmerAnimation": "p_ax",
  "SkeletonBodyText": "p_iv",
};

function SkeletonBodyText$1({ lines = 3 }) {
    const bodyTextLines = [];
    for (let i = 0; i < lines; i++) {
        bodyTextLines.push(createElement('div', { className: styles$54.SkeletonBodyText, key: i }));
    }
    return createElement(
        'div',
        { className: styles$54.SkeletonBodyTextContainer },
        bodyTextLines
    );
}

var styles$55 = {
  "Page": "p_gx",
  "fullWidth": "p_ru",
  "Content": "p_nr",
  "Header": "p_z9",
  "Header-hasSecondaryActions": "p_k4",
  "Actions": "p_qw",
  "Action": "p_re",
  "skeletonShimmerAnimation": "p_u6",
};

class SkeletonPage extends PureComponent {
    render() {
        const { children, fullWidth, secondaryActions, title = '', breadcrumbs } = this.props;
        const className = classNames(styles$55.Page, fullWidth && styles$55.fullWidth);
        const headerClassName = classNames(styles$55.Header, secondaryActions && styles$55['Header-hasSecondaryActions'], breadcrumbs && styles$55['Header-hasBreadcrumbs']);
        const titleMarkup = title !== null ? renderTitle(title) : null;
        const secondaryActionsMarkup = secondaryActions ? renderSecondaryActions(secondaryActions) : null;
        const breadcrumbMarkup = breadcrumbs ? renderSecondaryActions(1) : null;
        const headerMarkup = !this.context.easdk ? createElement(
            'div',
            { className: headerClassName },
            breadcrumbMarkup,
            titleMarkup,
            secondaryActionsMarkup
        ) : null;
        return createElement(
            'div',
            { className: className, role: 'status', 'aria-label': 'Page loading' },
            headerMarkup,
            createElement(
                'div',
                { className: styles$55.Content },
                children
            )
        );
    }
}
SkeletonPage.contextTypes = { easdk: object };
function renderSecondaryActions(actionCount) {
    const actions = [];
    for (let i = 0; i < actionCount; i++) {
        const width = Math.round(Math.random() * 40 + 60);
        actions.push(createElement(
            'div',
            { className: styles$55.Action, style: { width }, key: i },
            createElement(SkeletonBodyText$1, { lines: 1 })
        ));
    }
    return createElement(
        'div',
        { className: styles$55.Actions },
        actions
    );
}
function renderTitle(title) {
    const titleContent = title === '' ? createElement(SkeletonDisplayText$1, { size: 'large' }) : createElement(
        DisplayText$1,
        { size: 'large', element: 'h1' },
        title
    );
    return createElement(
        'div',
        { className: styles$55.Title },
        titleContent
    );
}

var styles$56 = {
  "ProgressBar": "p_h6",
  "sizeSmall": "p_q8",
  "sizeMedium": "p_t1",
  "sizeLarge": "p_mz",
  "Indicator": "p_as",
  "fillup": "p_sx",
  "Progress": "p_sa",
  "Label": "p_ng",
  "skeletonShimmerAnimation": "p_c8",
};

function ProgressBar$1({ progress = 0, size = 'medium' }) {
    const className = classNames(styles$56.ProgressBar, size && styles$56[variationName('size', size)]);
    const parsedProgress = parseProgress(progress);
    return createElement(
        'div',
        { className: className },
        createElement('progress', { className: styles$56.Progress, value: parsedProgress, max: '100' }),
        createElement(
            'div',
            { className: styles$56.Indicator, role: 'progressbar', 'aria-hidden': 'true', style: { width: `${parsedProgress}%` } },
            createElement(
                'span',
                { className: styles$56.Label },
                parsedProgress,
                '%'
            )
        )
    );
}
function parseProgress(progress) {
    let progressWidth;
    if (progress < 0) {
        if (process.env.NODE_ENV === 'development') {
            // eslint-disable-next-line no-console
            console.warn(`Values passed to the progress prop shouldn’t be negative. Resetting ${progress} to 0.`);
        }
        progressWidth = 0;
    } else if (progress > 100) {
        if (process.env.NODE_ENV === 'development') {
            // eslint-disable-next-line no-console
            console.warn(`Values passed to the progress prop shouldn’t exceed 100. Setting ${progress} to 100.`);
        }
        progressWidth = 100;
    } else {
        progressWidth = progress;
    }
    return progressWidth;
}

function useLinkComponent(LinkComponent) {
    UnstyledLink$1.use(LinkComponent);
}
if (typeof window !== 'undefined') {
    window.Polaris = window.Polaris || {};
    window.Polaris.VERSION = '1.14.1';
}

export { Keys, AccountConnection$1 as AccountConnection, ActionList$1 as ActionList, Avatar$1 as Avatar, Badge$1 as Badge, Banner$1 as Banner, Button$1 as Button, buttonFrom, buttonsFrom, ButtonGroup$1 as ButtonGroup, CalloutCard$1 as CalloutCard, Caption$1 as Caption, Card$1 as Card, Checkbox$1 as Checkbox, ChoiceList$1 as ChoiceList, Collapsible$1 as Collapsible, ColorPicker$1 as ColorPicker, rgbToHex, rgbToHsb, hsbToRgb, hsbToHex, rgbString, rgbaString, Connected$1 as Connected, DatePicker$1 as DatePicker, DescriptionList$1 as DescriptionList, DisplayText$1 as DisplayText, EmptyState$1 as EmptyState, EventListener$1 as EventListener, FooterHelp$1 as FooterHelp, FormLayout$1 as FormLayout, Heading$1 as Heading, Icon$1 as Icon, Image$1 as Image, KeyboardKey$1 as KeyboardKey, KeypressListener$1 as KeypressListener, Label$1 as Label, Labelled$1 as Labelled, Layout$1 as Layout, Link$1 as Link, ContentList as List, Page$1 as Page, PageActions$1 as PageActions, Pagination$1 as Pagination, Popover$2 as Popover, CloseSource as PopoverCloseSource, RadioButton$1 as RadioButton, ResourceList$1 as ResourceList, Scrollable$1 as Scrollable, Select$1 as Select, SettingToggle$1 as SettingToggle, Spinner$1 as Spinner, Stack$1 as Stack, Subheading$1 as Subheading, Tabs$1 as Tabs, Tag$1 as Tag, TextContainer$1 as TextContainer, TextField$1 as TextField, TextStyle$1 as TextStyle, Thumbnail$1 as Thumbnail, Tooltip$2 as Tooltip, UnstyledLink$1 as UnstyledLink, VisuallyHidden$1 as VisuallyHidden, SkeletonPage, SkeletonBodyText$1 as SkeletonBodyText, SkeletonDisplayText$1 as SkeletonDisplayText, ProgressBar$1 as ProgressBar, useLinkComponent };
export { Months } from '@shopify/javascript-utilities/dates';
